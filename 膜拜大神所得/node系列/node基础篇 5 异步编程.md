# 异步编程 (原文:深入浅出 Node.js)

一般函数：函数的`参数`只接受“基本的数据类型”或是“对象引用”，`返回值`也只是“基本数据类型”和“对象引用”。

高阶函数:则是可以把函数作为参数，或是将函数作为返回值的函数；例如 forEach()、map()、reduce()、reduceRight()、filter()、every()、some()

```
//======一般函数================
function foo(x) {
    return x;
}
/======高阶函数================
function foo(x) {
    return function () {
       return x;
    };
}
function foo(x, bar) {
    return bar(x);
}
```

Node 实现异步/O 的原理。利用事件循环的方式，JavaScript 线程像一个分配任务和处理结果的大管家，I/O 线程池里的各个 I/O 线程都是小二，负责兢兢业业地完成分配来的任务，小二与管家之间互不依赖，所以可以保持整休的高效率。

Node 是为了解决编程模型中阻塞 I/O 的性能问题的，采用了单线程模型，这导致 Node 更像一个处理/O 密集问题的能手，而 CPU 密集型则取决于管家的能耐如何。

## 编译难点

1. 异常处理：try/catch 处理不了；
2. 函数嵌套过深：
3. 代码阻塞：没有 java 的 sleep(),setTimeOut()不能阻塞代码；
4. 多线程编程：child_process 是基础 API，cluster 模块是更深层次应用；
5. 异步转同步：

- 解决方案：

  1. 事件发布/订阅模式：event 模块，node 中 emit()调用伴随着事件循环触发；

     用事件队列解决雪崩问题；

     在计算机中，缓存由于存放在内存中，访问速度十分快，常常用于加速数据访问，让绝大多数的请求不必重复去做一些低效的数据读取。  
     谓雪崩问题，就是在高访问量、大并发量的情况下缓存失效的情景，此时大量的请求同时涌入数据库中，数据库无法同时承受如此大的查询请求，进而往前影响到网站整体的响应速度。

  2. Promise/Deferred 模式
  3. 流程控制库
     - 尾触发与 next
     - async
     - Step
     - wind

## 异步并发控制----bagpipe/async 的解决方案

在 Node 中，我们可以十分方便地利用异步发起并行调用。使用下面的代码，我们可以轻松发起 100 次异步调用：

```
for (var i 0,i<100;i++){
    async();
}
```

但是如果并发量过大，我们的下层服务器将会吃不消。  
如果是对文件系统进行大量并发调用，操作系统的文件描述符数量将会被瞬间用光，抛出如下错误：Error:EMFILE,too many open files
