# 内存控制 (原文:深入浅出 Node.js)

- V8 的内存限制：64 位系统下：1.4G，32 位系统下 0.7G；  
  比如：node 无法将一个 2G 的文件读入内存中进行字符串分析处理（物理内存为 32G 也不行）；  
  破解限制的 2 种方法：必须初始化时

  1. node --max-new-space-size=1024 test.js // 单位为 KB
  2. node --max-old-space-size=1700 test.js // 单位为 MB

- V8 为何要限制大小：
  表层：V8 为浏览器设计的，不太可能用到大内存场景；
  深层：V8 的垃圾回收机制的限制；1.5G 垃圾回收堆内存，V8 做一次小的垃圾回收耗时 50 毫秒以上，做一次非增量式的垃圾回收要 1 秒以上，垃圾回收 js 线程暂停执行；前端和后端都无法接受。

## V8 的垃圾回收机制

- V8 将内存分为“新生代”和“老生代”两代；

  1. 新生代：中的对象为存活时间较短的对象；
     设置新生代内存空间的最大值：-max-new-space-size
     默认设置下：新生代最大内存 32MB（64 位系统），16MB（32 位系统）【可用的再减半】

  2. 老生代：中的对象为存活时间较长或常驻内存的对象；
     设置老生代内存空间的最大值：-max-old-space-size

- V8 推的整休大小 = 新生代所用内存空间 + 老生代的内存空间。
  V8 使用的内存没有办法根据使用情况自动扩充，当内存分配过程中超过极限值时，就会引起进程出错。

chrome 浏览器每个选项卡一个 V8,内存绰绰有余。
web 服务器会话一般通过内存储存，访问量大导致老生代中的对象剧增，造成清理/整理耗时，和内存紧张。

[详解 V8 回收机制](../2.浏览器系列/垃圾回事机制.md)

## 查看垃圾回收日志 -- 分析日志，优化代码

1. node --prof test01.js 产生 v8.log 日志文件；

2. V8 提供了 linux-tick-processor 工具用于“统计”、“分析”日志信息（加入环境变量）;
   linux-tick-processor v8.log

## 高效使用内存 -- JS 中无法立即回收内存的有闭包和全局变量；

1. 通过作用域 `{}`
2. 全局变量需要等到进程结束才能释放，全局变量主动释放：
   - 赋值 null / undefined
   - delete 删除（可能干扰 V8 优化）

**注：** 闭包影响作用域释放，进而影响内存释放

## 查看内存使用情况

1. 查看系统的内存占用

```
    os.totalmem() ：系统的总内存；（电脑的总内存）
    os.freemem() ：系统的闲置内存；
```

2. 查看进程的内存占用
   进程的内存总共有几部分，一部分是 rss,其余部分在交换区(swap)或者文件系统(filesystem)中。

```
process.memoryUsage();
{
  rss: 20926464, //进程的常驻内存
  heapTotal: 4481024, //V8的堆内存（堆中总共申请的内存）
  heapUsed: 2741000,//V8的堆内存（堆中使用的内存）
  external: 893780,
  arrayBuffers: 9898
}

```

3. 堆外内存
   通过 process.momoryUsage()的结果可以看到，堆中的内存用量总是 < 进程的常驻内存用量，这意味着 Node 中的内存使用并非都是通过 V8 进行分配的。

   我们将那些不是通过 V8 分配的内存称为堆外内存。

   例如 Buffer：这在于 Node 并不同于浏览器的应用场景。在浏览器中，JavaScript 直接处理字符串即可满足绝大多数的业务需求，而 Node 则需要处理网络流和文件 H/O 流，操作字符串远远不能满足传输的性能带求。

## 内存泄漏

1. 慎将内存当缓存
   - 所以在 Node 中，任何试图拿内存当缓存的行为都应当被限削。当然，这种限削并不是不允许使用的意思，而是要小心为之。
   - 对象的键值对缓存东西；要做限制；
   - 所有模块都会通过编译执行，然后被缓存起来，这样每个文件模块在编译执行后形成的作用域因为模块缓存的原因，不会被释放。由于模块的缓存机制，模块是常驻老生代的。
2. 缓存的解决方案
   - 将缓存转移到外部，减少常驻内存的对象的数量，让垃圾回收更高效。
   - 进程之间可以共享缓存。（Redis 和 Memcached）
3. 队列也可能产生内存泄漏；
   解决：超时和拒绝模式；

## 大内存应用

大文件读写用流（stream）;如果不需要进行字符串层面的操作，则不需要借助 V8 来处理，可以尝试进行纯粹的 Buffer 操作，这不会受到 V8 推内存的限削。但是这种大片使用内存的情况依然要小心，即使 V8 不限制堆内存的大小，物理内存依然有限制。
