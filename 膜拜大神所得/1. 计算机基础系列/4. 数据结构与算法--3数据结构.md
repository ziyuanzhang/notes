# 数据结构

1、线性结构（栈、队列、链表、数组）；
2、非线性结构（树、图）；
3、集合结构（集合-set、字典-map/dict）；

## 1、线性结构

1. 栈（Stack）：LIFO 后进先出，只能在栈顶操作；

   - 主要操作：入栈、出栈。
   - 应用场景：函数调用，表达式求值，浏览器后退

2. 队列（Queue）： FIFO 先进先出，队尾进、队首出；

   - 变种：普通队列、循环队列、双端队列（Deque）、优先队列（Priority Queue）。
   - 应用场景：任务调度、消息队列，CPU 调度，广度优先搜索（BFS）遍历；

3. 链表：有序，非连续内存，动态大小，插入删除 O(1)；

   - 结构：节点（Node）+ 指针（Next）。
   - 类型：单向链表、双向链表、循环链表。
   - 优点：插入、删除灵活。
   - 缺点：查找慢（O(n)）。
   - 应用场景：实现队列、栈、内存管理、LRU 缓存等；

4. 数组、列表(Array、List)：连续内存，随机访问 O(1)，大小固定

   - 优点：随机访问速度快（O(1)）。
   - 缺点：插入、删除慢。
   - 应用场景：基础数据存储，存储固定大小的列表，如图像像素、矩阵。

## 2.1、非线性结构 -- 树结构（tree）

1. 普通树:
2. 二叉树: 每个节点最多有两个子节点，称为左子节点和右子节点；

   - 应用场景：常用于实现堆、搜索树、表达式树等。

3. 二叉搜索树：左子节点 < 父节点 < 右子节点；

   - 应用场景：动态数据排序；

4. 平衡二叉树（AVL Tree、红黑树）：通过控制高度差保证操作效率；

   - 应用场景：搜索、插入、删除时间复杂度为 O(log n)；

   * `AVL 树`：严格平衡，左右子树高度差 ≤1；
   * `红黑树`：近似平衡，插入删除性能更好；

5. B 树 / B+ 树：多叉平衡搜索树；

   - 应用场景：数据库索引、文件系统

6. 堆（Heap）：一种完全二叉树

   - 父节点与子节点满足堆序性（大顶堆 / 小顶堆）

7. Trie（字典树 / 前缀树）：主要用于字符串检索（如自动补全、拼写检查）

- 二叉树的遍历

1. 前序遍历 :根 → 左 → 右 :复制树、表达式前缀
2. 中序遍历 :左 → 根 → 右 :排序输出 BST
3. 后序遍历 :左 → 右 → 根 :删除树、表达式求值
4. 层序遍历 :按层从上到下 :广度优先搜索 BFS

## 2.2、非线性结构 -- 图结构(Graph)

- 组成：顶点（Vertex）+ 边（Edge）。
- 类型：
  1. 无向图：边没有方向：社交网络，交通网络
  2. 有向图：边有方向：网页链接，任务依赖
  3. 带权图：边有权重： 最短路径，网络流

## 3、集合结构

1. Set(集合)：只存 “键（key）”，不存值（value）；无序且不重复的元素集合；

2. Map 、dict (映射 / 字典)：“键-值（key-value）对” 映射，无序，键唯一（值可重复）

   在计算机结构中，“字典”是抽象概念；“散列（Hashing）”是实现技术；“散列表（哈希表-Hash Table）”是这种技术的具体数据结构。

   - 字典 Dictionary：抽象概念

     1. 可用“树”实现
     2. 可用“散列“实现 → Hash Table（结构）← Hashing（散列技术）

   - **注：** Map 和 Set 与其弱化版本之间仅有的区别是：

     1. WeakSet 或 WeakMap 类没有 entries、keys 和 values 等方法；
     2. 只能用对象作为键。

3. 散列表（哈希表）：键值对映射，平均 O(1)查找
   - 数组 + 散列函数(例：取余函数 等)
   - 应用场景：字典，缓存系统，数据库索引

## 建议

- 就复杂性而言:

  1. 队列和栈是最简单的,可以由链表构造；
  2. 树和图是最复杂的，因为它们在链表的结构上进行了扩展；
  3. 哈希表需要利用这些数据结构来可靠地执行;

- 就效率而言:
  1. 链表最适合记录和存储数据;
  2. 哈希表最适合检索数据;

[原文](http://caibaojian.com/learn-javascript.html)
