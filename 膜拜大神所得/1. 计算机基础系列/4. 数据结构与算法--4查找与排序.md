# 查找与排序

## 查找

1. 顺序查找：从头到尾与表中元素比较；
2. 二分查找（折半查找）：（前提：原始数据是`有序数组`）

   - mid = (low+high)/2
   - 复杂度：O(log<sub>2</sub>n)

## 排序

1. 冒泡排序：两两比较，交换位置；【稳定--O(n<sup>2</sup>)】
   ```
       let arr = [2, 5, 3, 5, 7, 1, 10, 20, 10];
       for (let i = 0; i < arr.length; i++) {
           for (let j = 0; j < arr.length; j++) {
               if (arr[i] > arr[j]) {
                   let temp = arr[i];
                   arr[i] = arr[j];
                   arr[j] = temp
               }
           }
       }
       console.log(arr)
   ```
2. 选择排序：选择最小的和第一个交换位置，剩余中选择最小的和第二个交换位置，以此类推；

   ```
     let arr = [2, 5, 3, 5, 7, 1, 10, 20, 10];
     for (let i = 0; i < arr.length; i++) {
         let max = arr[i]
         let index = i;
         for (let j = i; j < arr.length; j++) {
             if (arr[j] > max) {
                 max = arr[j];
                 index = j;
             }
         }
         arr[index] = arr[i];
         arr[i] = max;

     }
     console.log(arr)
   ```

3. 插入排序：当前元素与已排元素比较，插入对应位置；【稳定】【小型数组时，比 “选择” / “冒泡” 性能好】

   ```
        let arr = [2, 5, 3, 5, 7, 1, 10, 20, 10];
        for (let i = 0; i < arr.length; i++) {
            for (let j = i; j >= 0; j--) {
                let temp = arr[j]
                if (arr[j] < arr[j - 1]) {
                    arr[j] = arr[j - 1];
                    arr[j - 1] = temp;
                }
            }
        }
        console.log(arr)
   ```

   ==================================

4. 快速排序：（边分解，边排序）长度>1，

   - 1、 找到基准的元素（取平均数），比它小的放左边数组，比它大的放右边数组；
   - 2、 对左右数组，各找出基准元素；比它小的放左边数组，比它大的放右边数组；
   - 3、 一次类推；
   - 4、合并

5. 归并排序/合并排序：（先分解，再合并）长度>1，【稳定--O(n log<sub>2</sub>n)】

   - 1、两两分组，再排序；【1、2】【3、4】【5、6】【7、8】
   - 2、相邻两组，依次比较、获取最小值、排序； 【1、2、3、4】【5、6、7、8】
   - 3、以此类推；

   ==================================

6. 计数排序（整数排序算法）：（分布式排序）

   - 1、取最大值（maxVal）；
   - 2、新建临时数组，长度:（maxVal+1）填充值：0【tempArr = new Array(8).fill(0)】；
   - 3、循环原始数组，以其值（val）为临时数组的下标，值＋ 1（tempArr[val]++）；
   - 4、创建新数组，循环临时数组（tempArr），其值大于 0 的，新数组添加对应个数的下标

7. 桶排序（箱排序）：（分布式排序）长度>1，

   - 每个桶放 n 个数，桶数 M=Math.floor((maxVal-minVal)/n)+1，每个桶存值范围：Math.floor((arr[i]-minVal)/n)；
   - 循环数组放对应下标的桶中，每个桶用“插入排序”，扩展合并每个桶；

8. 基数排序：（分布式排序）长度>1，【稳定--O(d(n+rd)) 】
   - 1、按进制放 n 个桶，8 进制 8 个；10 进制 10 个；
   - 2、按个位数字放对应桶中，再按顺序把桶里的数取出来，形成一个新的序列；
   - 3、一次类推；再按十位、百位 循环直到最大位数。

### 排序选择：

1. 当数据 n 较小时，采用 直接插入排序/简单选择排序；
2. 当数据基本有序，采用 直接插入排序/冒泡排序；
3. 当 n 很大且`关键字【位数较少】`时，采用 基数排序；

### 算法策略

1. 分治法：一定会用递归；归并排序、快速排序、二分搜索
2. 贪心法：局部最优，但整体不见得最优。背包问题、找零问题、最小生成树；
3. 动态规划法：“最优子结构”-要解决规模为 n 的，必须先解决小规模的，才能解决 n 的；斐波那契数列（12358...）
4. 回溯法：如果不通，回到上一个点；
