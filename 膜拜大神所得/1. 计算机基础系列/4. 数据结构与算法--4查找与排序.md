# 查找与排序

## 查找

1. 顺序查找：从头到尾与表中元素比较；
2. 二分查找（折半查找）：（前提：原始数据是`有序数组`）

   - mid = (low+high)/2
   - 复杂度：O(log<sub>2</sub>n)

## 排序

1. 冒泡排序：两两比较，交换位置；【稳定--O(n<sup>2</sup>)】

   ```code
       let arr = [2, 5, 3, 5, 7, 1, 10, 20, 10];
       for (let i = 0; i < arr.length; i++) {
           for (let j = 0; j < arr.length; j++) {
               if (arr[i] > arr[j]) {
                   let temp = arr[i];
                   arr[i] = arr[j];
                   arr[j] = temp
               }
           }
       }
       console.log(arr)
   ```

2. 选择排序：选择最小的和第一个交换位置，剩余中选择最小的和第二个交换位置，以此类推；

   ```code
     let arr = [2, 5, 3, 5, 7, 1, 10, 20, 10];
     for (let i = 0; i < arr.length; i++) {
         let max = arr[i]
         let index = i;
         for (let j = i; j < arr.length; j++) {
             if (arr[j] > max) {
                 max = arr[j];
                 index = j;
             }
         }
         arr[index] = arr[i];
         arr[i] = max;
     }
     console.log(arr)
   ```

3. 插入排序：当前元素与已排元素比较，插入对应位置；【稳定】【小型数组时，比 “选择” / “冒泡” 性能好】

   ```code
     let arr = [2, 5, 3, 5, 7, 1, 10, 20, 10];
     for (let i = 0; i < arr.length; i++) {
         for (let j = i; j >= 0; j--) {    //--注意---
             let temp = arr[j]
             if (arr[j] < arr[j - 1]) {
                 arr[j] = arr[j - 1];
                 arr[j - 1] = temp;
             }
         }
     }
     console.log(arr)
   ```

4. 快速排序：（边分解，边排序）长度>1，

   - 1、 找到基准的元素（取平均数），比它小的放左边数组，比它大的放右边数组；
   - 2、 对左右数组，各找出基准元素；比它小的放左边数组，比它大的放右边数组；
   - 3、 一次类推；
   - 4、合并

5. 归并排序/合并排序：（先分解，再合并）长度>1，【稳定--O(n log<sub>2</sub>n)】

   - 1、两两分组，再排序；【1、2】【3、4】【5、6】【7、8】
   - 2、相邻两组，依次比较、获取最小值、排序； 【1、2、3、4】【5、6、7、8】
   - 3、以此类推；

6. 计数排序（整数排序算法）：（分布式排序）

   - 1、取最大值（maxVal）；
   - 2、新建临时数组，长度:（maxVal+1）填充值：0【tempArr = new Array(8).fill(0)】；
   - 3、循环原始数组，以其值（val）为临时数组的下标，值＋ 1（tempArr[val]++）；
   - 4、创建新数组，循环临时数组（tempArr），其值大于 0 的，新数组添加对应个数的下标

7. 桶排序（箱排序）：（分布式排序）长度>1，

   - 每个桶放 n 个数，桶数 M=Math.floor((maxVal-minVal)/n)+1，每个桶存值范围：Math.floor((arr[i]-minVal)/n)；
   - 循环数组放对应下标的桶中，每个桶用“插入排序”，扩展合并每个桶；

8. 基数排序：（分布式排序）长度>1，【稳定--O(d(n+rd)) 】
   - 1、按进制放 n 个桶，8 进制 8 个；10 进制 10 个；
   - 2、按个位数字放对应桶中，再按顺序把桶里的数取出来，形成一个新的序列；
   - 3、一次类推；再按十位、百位 循环直到最大位数。

### 排序选择

1. 当数据 n 较小时，采用 直接插入排序/简单选择排序；
2. 当数据基本有序，采用 直接插入排序/冒泡排序；
3. 当 n 很大且`关键字【位数较少】`时，采用 基数排序；

## 算法策略

1. 分治法：一定会用递归；归并排序、快速排序、二分搜索
2. 贪心法：局部最优，但整体不见得最优。背包问题、找零问题、最小生成树；
3. 动态规划法：“最优子结构”-要解决规模为 n 的，必须先解决小规模的，才能解决 n 的；斐波那契数列（12358...）
4. 回溯法：如果不通，回到上一个点；

### 前端十大算法

https://blog.csdn.net/weixin_38984353/article/details/80393412

1. 冒泡排序
   具体算法描述如下：
   <1>.比较相邻的元素。如果第一个比第二个大，就交换它们两个；
   <2>.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
   <3>.针对所有的元素重复以上的步骤，除了最后一个；
   <4>.重复步骤 1~3，直到排序完成
2. 选择排序
   n 个记录的直接选择排序可经过 n-1 趟直接选择排序得到有序结果。具体算法描述如下：
   <1>.初始状态：无序区为 R[1..n]，有序区为空；
   <2>.第 i 趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为 R[1..i-1]和 R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第 1 个记录 R 交换，使 R[1..i]和 R[i+1..n)分别变为记录个数增加 1 个的新有序区和记录个数减少 1 个的新无序区；
   <3>.n-1 趟结束，数组有序化了。
3. 插入排序
   一般来说，插入排序都采用 in-place 在数组上实现。具体算法描述如下：
   <1>.从第一个元素开始，该元素可以认为已经被排序；
   <2>.取出下一个元素，在已经排序的元素序列中从后向前扫描；
   <3>.如果该元素（已排序）大于新元素，将该元素移到下一位置；
   <4>.重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；
   <5>.将新元素插入到该位置后；
   <6>.重复步骤 2~5。
4. 希尔排序
   先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：
   <1>. 选择一个增量序列 t1，t2，…，tk，其中 ti>tj，tk=1；
   <2>.按增量序列个数 k，对序列进行 k 趟排序；
   <3>.每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。
5. 归并排序
   具体算法描述如下：
   <1>.把长度为 n 的输入序列分成两个长度为 n/2 的子序列；
   <2>.对这两个子序列分别采用归并排序；
   <3>.将两个排序好的子序列合并成一个最终的排序序列。
6. 快速排序
   快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：
   <1>.从数列中挑出一个元素，称为 “基准”（pivot）；
   <2>.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
   <3>.递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。
7. 堆排序
   具体算法描述如下：
   <1>.将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；
   <2>.将堆顶元素 R[1]与最后一个元素 R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足 R[1,2…n-1]<=R[n]；
   <3>.由于交换后新的堆顶 R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将 R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为 n-1，则整个排序过程完成。
8. 计数排序
   具体算法描述如下：
   <1>. 找出待排序的数组中最大和最小的元素；
   <2>. 统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项；
   <3>. 对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）；
   <4>. 反向填充目标数组：将每个元素 i 放在新数组的第 C(i)项，每放一个元素就将 C(i)减去 1。
9. 桶排序
   具体算法描述如下：
   <1>.设置一个定量的数组当作空桶；
   <2>.遍历输入数据，并且把数据一个一个放到对应的桶里去；
   <3>.对每个不是空的桶进行排序；
   <4>.从不是空的桶里把排好序的数据拼接起来。
10. 基数排序
    具体算法描述如下：
    <1>.取得数组中的最大数，并取得位数；
    <2>.arr 为原始数组，从最低位开始取每个位组成 radix 数组；
    <3>.对 radix 进行计数排序（利用计数排序适用于小范围数的特点）；
