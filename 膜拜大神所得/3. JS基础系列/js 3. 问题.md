# js 问题

## 变量提升：javascript 代码是按顺序执行的吗

js 先编译后解析；

1. 在编译阶段，变量和函数会被存放到变量环境中，

   - 变量：默认值会被设置为 undefined；
   - 两个相同的函数：最终放在变量环境中的是最后定义的那个（后定义的覆盖先定义的）；

2. 在代码执行阶段，JavaScript 引擎会从变量环境中查找自定义的变量和函数；

## 块级作用域：var 缺陷以及为什么要引入 let 和 const

let、const 申明的变量不会被提升。在 js 引擎编译后，会保存在词法环境中。
词法环境内部维护一个小型的栈结构，作用域内部变量压入栈顶。作用域执行完，从栈顶弹出。

## this：从 JavaScript 执行上下文视角讲 this

当执行 new CreateObj 的时候，JavaScript 引擎做了四件事：

1. 首先创建一个控对象 tempObj；
2. 接着调用 CreateObj.call 方法，并将 tempObj 作为 call 方法的参数，这样当 createObj 的执行上下文创建时，它的 this 就指向 tempObj 对象；
3. 然后执行 CreateObj 函数，此时的 CreateObj 函数执行上下文中的 this 指向 tempObj 对象；
4. 最后返回 tempObj 对象。

- 直接调用函数，在严格模式下，this 值是 undefined，非严格模式下 this 指向的是全局对象 window；
- 箭头函数没有自己的执行上下文，this 是外层函数的 this；
- 谁调用函数，this 指向谁；

## 调用栈：为什么 js 代码会出现栈溢出

js 代码出现栈溢出错误: 通常是由于递归调用或者嵌套函数调用过多导致的。

每当 JavaScript 代码执行到一个函数时，引擎会创建一个“执行上下文对象”，该对象包含了当前函数的所有变量、函数参数、作用域链以及其他执行相关的信息。执行上下文对象保存在一个称为“执行栈”或“调用栈”中。

如果函数递归调用（即函数内部调用自己）并且递归深度很长 或者 存在大量的嵌套函数调用 调用链很长，调用栈可能会不断增长。当调用栈超过其最大容量时，就会发生栈溢出错误。

“执行上下文对象”包含以下重要的属性和组成部分：
变量环境（Variable Environment）：用于存储声明的变量、函数声明和函数参数。
词法环境（Lexical Environment）：包含变量环境，并构成了作用域链（Scope Chain）。
外部环境（Outer Environment）：指向外部（父级）执行上下文的词法环境，用于处理作用域链和词法嵌套。
this 值：指向当前函数执行的上下文对象内部的 this 关键字。
闭包函数：如果当前函数是一个闭包，执行上下文对象中还会包含闭包的引用和相关信息。

当函数执行完毕后，执行上下文对象将被销毁，从执行栈中弹出。但是，如果函数是一个闭包并且被外部引用，它的执行上下文可能会被保留在内存中，以供后续访问和使用。

## 作用域链和闭包

根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使外部函数已经执行结束了，但是内部函数引用外部函数的变量依旧保存在内存中，把这些变量的集合称为闭包；

## 栈空间和堆空间：数据是如何存储的

动态语言：在使用时需要检查数据类型的语言。
弱类型语言：支持隐式转换的语言。
js 数据类型：可以分为两大类——原始类型和引用类型。
原始类型数据存放在栈中；引用类型数据存放在堆中，堆中的数据是通过引用与变量关系联系起来的。瑞医

## 垃圾回收：垃圾数据如何自动回收

栈中数据回收：执行状态指针 ESP 在执行栈中移动，移过某执行上下文，就会被销毁；
堆中数据回收：V8 引擎采用标记-清除算法；

## 编译器和解析器：V8 如何执行一段 JavaScript 代码的

计算机语言可以分为两种：编译型和解释型语言。
编译型语言：经过编译器编译后保留机器能读懂的二进制文件，比如 C/C++，go 语言。
解释型语言: 是在程序运行时通过解释器对程序进行动态解释和执行，比如 Python，JavaScript 语言。

- 编译型语言的编译过程：编译器首先将代码进行词法分析、语法分析，生成抽象语法树（AST），然后优化代码，最后生成处理器能够理解的机器码；
- 解释型语言解释过程：解释器会对代码进行词法分析、语法分析，并生产抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后根据字节码执行程 序；
- AST 的生成：第一阶段是分词（词法分析），将一行行源码拆解成一个个 token（语法上不可再分、最小单个字符）。第二阶段是解析（语法分析），将上一步 生成的 token 数据，根据语法规则转为 AST，这一阶段会检查语法错误；
- 字节码存在的意义：直接将 AST 转化为机器码，执行效率是非常高，但是消耗大量内存，从而先转化为字节码解决内存问题；
- 解释器 ignition 在解释执行字节码，同时会手机代码信息，发现某一部分代码是热点代码（HotSpot），编译器把热点的字节码转化为机器码，并保存起来， 下次使用；
- 字节码配合解释器和编译器的计数实现称为即时编译（JIT）。

## 页面性能：如何系统优化页面

1. 加载阶段：减少关键资源个数，降低关键资源大小，降低关键资源的 RTT 次数；
2. 交互阶段：减少 JavaScript 脚本执行时间，避免强制同步布局：操作 DOM 的同时获取布局样式会引发，避免布局抖动：多次执行强制布局和抖动，合理利
3. 用 CSS 合成动画：标记 will-change，避免频繁的垃圾回收；
   CSS 实现一些变形、渐变、动画等特效，这是由 CSS 触发的，并且是在合成线程中执行，这个过程称为合成，它不会触发重排或者重绘；

## PWA：解决 web 应用哪些问题

- PWA（Progressive Web App），渐进式 Web 应用。一个渐进式过渡方案，让普通站点过渡到 Web 应用，降低站点改造代价，逐渐支持新技术，而不是一步到位；
- PWA 引入 ServiceWorker 来试着解决离线存储和消息推送问题，引入 mainfest.json 来解决一级入口问题；
- 暗转了 ServiceWorker 模块之后，WebApp 请求资源时，会先通过 ServiceWorker，让它判断是返回 Serviceworker 缓存的资源还是重新去网络请求资源，一切的控制权交给 ServiceWorker 来处理；
- 在目前的 Chrome 架构中，Service Worker 是运行在浏览器进程中的，因为浏览器进程生命周期是最长的，所以在浏览器的生命周期内，能够为所有的页面提供服务；

## WebComponent：像搭积木一样构建 web 应用

- CSS 的全局属性会阻碍组件化，DOM 也是阻碍组件化的一个因素，因为页面中只有一个 DOM，任何地方都可以直接读取和修改 DOM；
- WebComponent 提供了对局部试图封装能力，可以让 DOM、CSSOM 和 JavaScript 运行在局部环境中；
- template 创建模版，查找模版内容，创建影子 DOM，模版添加到影子 DOM 上；
- 影子 DOM 可以隔离全局 CSS 和 DOM，但是 JavaScript 是不会被隔离的；

## HTTP1 / HTTP2 / HTTP3

1. HTTP/0.9: 基于 TCP 协议，三次握手建立连接，发送一个 GET 请求行（没有请求头和请求体），服务器接收请求之后，读取对应 HTML 文件，数据以 ASCII 字符流返回，传输完成断开连接；

2. HTTP/1.0: 增加请求头和响应头来进行协商，在发起请求时通过请求头告诉服务器它期待返回什么类型问题、什么形式压缩、什么语言以及文件编码。引入来状态吗，Cache 机制等；

3. HTTP/1.1:

   - 改进持久化连接，解决建立 TCP 连接、传输数据和断开连接带来的大量开销，支持在一个 TCP 连接上可以传输多个 HTTP 请求，目前浏览器对于一个域名同时允许建立 6 个 TCP 持久连接；
   - 引入 Chunk transfer 支持动态生成内容：服务器将数据分割成若干任意大小的数据块，每个数据块发送时附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。在 HTTP/1.1 需要在响应头中设置完整的数据大小，如 Content-Length。
   - **问题**：TCP 慢启动；同时开启多条 TCP 连接，会竞争固定宽带；对头阻塞问题；

4. HTTP/2 :

   - 同一个域名下只使用一个 TCP 长连接和消除对头阻塞问题；
   - 多路复用的实现：HTTP/2 添加了二进制分帧层，将发送或响应数据经过二进制分帧处理，转化为一个个带有请求 ID 编号的帧，服务器或者浏览器接收到响应帧后，根据相同 ID 帧合并为一条完整信息；
   - 设置请求优先级：发送请求可以设置请求优先级，服务器可以优先处理；
   - 服务器推送：请求一个 HTML 页面，服务器可以知道引用了哪些 JavaScript 和 CSS 文件，附带一起发送给浏览器；
   - 头部压缩：对请求头和响应头进行压缩；
   - **TCP 问题**：如果在传输过程中，有一个数据因为网络故障或者其他原因丢失，那么整个连接会处于暂停状态，只有等到该数据重新传输；

5. HTTP/3
   - HTTP/3 选择了一个折衷的方法，基于现有的 UDP 协议，实现类似 TCP 多路复用，传输可靠等功能，称为 QULC 协议；
   - QULC 实现类似 TCP 流量控制，传输可靠功能；集成 TLS 加密功能；实现多路复用功能；

## HTTPS

1. 在 TCP 和 HTTP 之间插入一个安全层，所有经过安全层的数据都会被加密或者解密；
2. 对称加密：
   浏览器发送加密套件列表和一个随机数 client-random，服务器会从加密套件中选取一个加密套件，然后生成一个随机数 service-random，返回给浏览器。这样浏览器和服务器都有相同 client-random 和 service-random，再用相同的方法将两者混合生成一个密钥 master secret，双方就可以进行数据加密传输了；
   - 缺点：client-random 和 service-random 的过程都是明文，黑客可以拿到协商的加密套件和双方随机数，生成密钥，数据可以被破解；
3. 非对称加密：
   浏览器发送加密套件列表给服务器，服务器选择一个加密套件，返回加密套件和公钥，浏览器用公钥加密数据，服务器用私钥解密；
   - 缺点：加密效率太低；初次通信黑客可以获取公钥。
4. 对称加密结合非对称加密：初次非对称，以后对称；

**注：**2 种加密方式 理论上都可以暴力破解；对称加密破解的概率大点；

## 同源策略：协议、域名和端口号相同的 URL 是同源的

## XSS 攻击(跨站脚本攻击)：为什么 cookie 中有 httpOnly 属性

1. XSS 跨站脚本，往 HTML 文件中注入恶意代码，对用户实施攻击；
2. XSS 攻击:主要有存储型 XSS 攻击、反射型 XSS 攻击和 DOM 的 XSS 攻击；
   存储型 XSS 攻击：(持久型)提交了数据，并且存入了数据库，别人访问这个页面的时候就会自动出发;
   反射型 XSS 攻击：(非持久型)提交了数据，但是这是对你这次访问产生了影响，并非持久性攻击;
   DOM 的 XSS 攻击：通过 JS 代码对网页进行修改，变化和执行。当 JS 代码执行后的结果产生了 XSS 漏洞的话，这就是 DOM 型 XSS，再根据该 XSS 能否被存储进数据库中，可再细分为反射型和存储型;
3. 阻止 XSS 攻击： 服务器对脚本进行过滤或转码，利用 CSP 策略，使用 HttpOnly；

## CSRF 攻击：陌生连接不要随便点

1. CSRF 跨站请求伪造，利用用户的登录状态，通过第三方站点攻击；
2. 避免 CSRF 攻击：
   - 利用 SameSite（三种模式：Strict、Lax、None） 让浏览器禁止第三方站点发起请求携带关键 Cookie；
   - 验证请求的来源站点，请求头中的 Referer 和 Origin 属性；利用 CSRF Token；

## 默认浏览器、手机 webview 内核、各家小程序的运行环境

H5 页面：运行环境 1、浏览器；2、APP 的 web-view 组件；3、小程序提供的 web-view 组件；
微信小程序：运行环境是非完整的浏览器，是基于浏览器内核完全重构的一个内置解析器，针对小程序专门做了优化（功能和流畅性更好）

## JQ 中类似 promise

$.when().done().fail().then()

## JQ 中 prop 和 attr 的区别

prop 方法: 对于元素本身就带有的固有属性
attr 方法: 对于元素我们自己自定义的 DOM 属性
