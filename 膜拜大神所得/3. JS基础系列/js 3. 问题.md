# js 问题

array 与 string 共用方法：
concat(" world","!");
slice(0, 3) --3 下标,返回截取的;
length;
arr[0] / str[0]
indexOf('world')
includes()

| array 与 string 共用方法         | string                                | array                                         |
| -------------------------------- | :------------------------------------ | :-------------------------------------------- |
| concat(" world","!");            | str.split(",") 分割                   | arr.join(",")  ---  arr.toString()            |
| slice(0, 3) --3 下标,返回截取的; | =================                     | =========================                     |
| length;                          | str.toUpperCase()                     | arr.splice(1,2,"d","e")                       |
| arr[0] / str[0];                 | str.toLowerCase()                     | ========================                      |
| indexOf('world');                | ================                      | arr.push('a','b') 添加                        |
| includes;                        | str.trim()                            | arr.pop() 删除最后一个                        |
|                                  | str.charAt()                          | arr.unshift("a","b") 添加                     |
|                                  | ===============                       | arr.shift() 删除第一个                        |
|                                  | str.substring(3,7) --7 为下标         | =======================                       |
|                                  | str.substr(0, 5)  ---5 为长度         | arr.sort()  ---  对数组进行排序               |
|                                  | ================                      | arr.reverse()  ---对数组进行反转              |
|                                  | str.match（找到一个或多个正则的匹配） | ========================                      |
|                                  | str.search(检索与正则匹配的值)        | arr.map()                                     |
|                                  | str.replace(替换与正则匹配的子串)     | arr.forEach()                                 |
|                                  | =========                             | arr.filter()                                  |
|                                  | =========                             | arr.some()                                    |
|                                  | =========                             | arr.every()                                   |
|                                  | =========                             | arr.reduce(callBack(prev,cur,index,arr),init) |

## 变量提升：javascript 代码是按顺序执行的吗

js 先编译后解析；

1. 在编译阶段，变量和函数会被存放到变量环境中，

   - 变量：默认值会被设置为 undefined；
   - 两个相同的函数：最终放在变量环境中的是最后定义的那个（后定义的覆盖先定义的）；

2. 在代码执行阶段，JavaScript 引擎会从变量环境中查找自定义的变量和函数；

## 块级作用域：var 缺陷以及为什么要引入 let 和 const

let、const 申明的变量不会被提升。在 js 引擎编译后，会保存在词法环境中。
词法环境内部维护一个小型的栈结构，作用域内部变量压入栈顶。作用域执行完，从栈顶弹出。

## this：从 JavaScript 执行上下文视角讲 this

当执行 new CreateObj 的时候，JavaScript 引擎做了四件事：

1. 首先创建一个控对象 tempObj；
2. 接着调用 CreateObj.call 方法，并将 tempObj 作为 call 方法的参数，这样当 createObj 的执行上下文创建时，它的 this 就指向 tempObj 对象；
3. 然后执行 CreateObj 函数，此时的 CreateObj 函数执行上下文中的 this 指向 tempObj 对象；
4. 最后返回 tempObj 对象。

- 直接调用函数，在严格模式下，this 值是 undefined，非严格模式下 this 指向的是全局对象 window；
- 箭头函数没有自己的执行上下文，this 是外层函数的 this；
- 谁调用函数，this 指向谁；

## 调用栈：为什么 js 代码会出现栈溢出

js 代码出现栈溢出错误: 通常是由于递归调用或者嵌套函数调用过多导致的。

每当 JavaScript 代码执行到一个函数时，引擎会创建一个“执行上下文对象”，该对象包含了当前函数的所有变量、函数参数、作用域链以及其他执行相关的信息。执行上下文对象保存在一个称为“执行栈”或“调用栈”中。

如果函数递归调用（即函数内部调用自己）并且递归深度很长 或者 存在大量的嵌套函数调用 调用链很长，调用栈可能会不断增长。当调用栈超过其最大容量时，就会发生栈溢出错误。

“执行上下文对象”包含以下重要的属性和组成部分：
变量环境（Variable Environment）：用于存储声明的变量、函数声明和函数参数。
词法环境（Lexical Environment）：包含变量环境，并构成了作用域链（Scope Chain）。
外部环境（Outer Environment）：指向外部（父级）执行上下文的词法环境，用于处理作用域链和词法嵌套。
this 值：指向当前函数执行的上下文对象内部的 this 关键字。
闭包函数：如果当前函数是一个闭包，执行上下文对象中还会包含闭包的引用和相关信息。

当函数执行完毕后，执行上下文对象将被销毁，从执行栈中弹出。但是，如果函数是一个闭包并且被外部引用，它的执行上下文可能会被保留在内存中，以供后续访问和使用。

## 作用域链和闭包

根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使外部函数已经执行结束了，但是内部函数引用外部函数的变量依旧保存在内存中，把这些变量的集合称为闭包；

## 栈、堆、队列之间的区别是？

动态语言：在使用时需要检查数据类型的语言。
弱类型语言：支持隐式转换的语言。

1. 栈：基本数据类型，上下文切换之后，栈顶的空间会自动被回收（像 桶 先进后出）
2. 堆：引用数据类型，需要垃圾回收机制不定时回收；变量存储的是指针，指向堆中（书架中的书，知道书名就可以拿到书，可以无序）
3. 队列只能在队头做删除操作,在队尾做插入操作。（先进先出）
   理解队列数据结构的目的主要是为了清晰的明白事件循环机制

## 垃圾回收：垃圾数据如何自动回收

栈中数据回收：执行状态指针 ESP 在执行栈中移动，移过某执行上下文，就会被销毁；
堆中数据回收：V8 引擎采用标记-清除算法；

- 注：在垃圾回收阶段，应用程序的执行会暂停，等待回收执行完毕后，再恢复程序的执行。

## 编译器和解析器：V8 如何执行一段 JavaScript 代码的

计算机语言可以分为两种：编译型和解释型语言。
编译型语言：经过编译器编译后保留机器能读懂的二进制文件，比如 C/C++，go 语言。
解释型语言: 是在程序运行时通过解释器对程序进行动态解释和执行，比如 Python，JavaScript 语言。

- 编译型语言的编译过程：编译器首先将代码进行词法分析、语法分析，生成抽象语法树（AST），然后优化代码，最后生成处理器能够理解的机器码；
- 解释型语言解释过程：解释器会对代码进行词法分析、语法分析，并生产抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后根据字节码执行程 序；
- AST 的生成：第一阶段是分词（词法分析），将一行行源码拆解成一个个 token（语法上不可再分、最小单个字符）。第二阶段是解析（语法分析），将上一步 生成的 token 数据，根据语法规则转为 AST，这一阶段会检查语法错误；
- 字节码存在的意义：直接将 AST 转化为机器码，执行效率是非常高，但是消耗大量内存，从而先转化为字节码解决内存问题；
- 解释器 ignition 在解释执行字节码，同时会手机代码信息，发现某一部分代码是热点代码（HotSpot），编译器把热点的字节码转化为机器码，并保存起来， 下次使用；
- 字节码配合解释器和编译器的计数实现称为即时编译（JIT）。

## 页面性能：如何系统优化页面

一个页面有三个阶段：加载阶段、交互阶段和关闭阶段。

1. 加载阶段：

   - 减少关键资源个数;
   - 降低关键资源大小;
   - 降低关键资源的 RTT（Round Trip Time） 次数;
     RTT 就是这里的往返时延。它是网络中一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认，总共经历的时延。

2. 交互阶段：尽量减少一帧的生成时间。

   - 减少 js 脚本执行时间。
   - 避免强制同步布局：js 强制将“计算样式”和“布局操作”提前到当前的任务中。
   - 避免布局抖动： 在一段 js 代码中，反复执行布局操作。
   - 合理利用 CSS 合成动画：标记 will-change。
     合成动画是在“合成线程”上执行的；如果主线程被 js 或者一些布局任务占用，CSS 动画依然能继续执行（它不会触发重排或者重绘）。
   - 避免频繁的垃圾回收。

## PWA：解决 web 应用哪些问题

- PWA（Progressive Web App），渐进式 Web 应用。一个渐进式过渡方案，让普通站点过渡到 Web 应用，降低站点改造代价，逐渐支持新技术，而不是一步到位；
- PWA 引入 ServiceWorker 来试着解决离线存储和消息推送问题，引入 mainfest.json 来解决一级入口问题；
- 暗转了 ServiceWorker 模块之后，WebApp 请求资源时，会先通过 ServiceWorker，让它判断是返回 Serviceworker 缓存的资源还是重新去网络请求资源，一切的控制权交给 ServiceWorker 来处理；
- 在目前的 Chrome 架构中，Service Worker 是运行在浏览器进程中的，因为浏览器进程生命周期是最长的，所以在浏览器的生命周期内，能够为所有的页面提供服务；

## WebComponent：像搭积木一样构建 web 应用

- CSS 的全局属性会阻碍组件化，DOM 也是阻碍组件化的一个因素，因为页面中只有一个 DOM，任何地方都可以直接读取和修改 DOM；
- WebComponent 提供了对局部试图封装能力，可以让 DOM、CSSOM 和 JavaScript 运行在局部环境中；
- template 创建模版，查找模版内容，创建影子 DOM，模版添加到影子 DOM 上；
- 影子 DOM 可以隔离全局 CSS 和 DOM，但是 JavaScript 是不会被隔离的；

## HTTP1 / HTTP2 / HTTP3

1. HTTP/0.9: 基于 TCP 协议，三次握手建立连接，发送一个 GET 请求行（没有请求头和请求体），服务器接收请求之后，读取对应 HTML 文件，数据以 ASCII 字符流返回，传输完成断开连接；

2. HTTP/1.0: 增加请求头和响应头来进行协商，在发起请求时通过请求头告诉服务器它期待返回什么类型问题、什么形式压缩、什么语言以及文件编码。引入来状态吗，Cache 机制等；

3. HTTP/1.1:

   - 改进持久化连接，解决建立 TCP 连接、传输数据和断开连接带来的大量开销，支持在一个 TCP 连接上可以传输多个 HTTP 请求，目前浏览器对于一个域名同时允许建立 6 个 TCP 持久连接；
   - 引入 Chunk transfer 支持动态生成内容：服务器将数据分割成若干任意大小的数据块，每个数据块发送时附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。在 HTTP/1.1 需要在响应头中设置完整的数据大小，如 Content-Length。
   - **问题**：TCP 慢启动；同时开启多条 TCP 连接，会竞争固定宽带；对头阻塞问题；

4. HTTP/2 :

   - 同一个域名下只使用一个 TCP 长连接和消除对头阻塞问题；
   - 多路复用的实现：HTTP/2 添加了二进制分帧层，将发送或响应数据经过二进制分帧处理，转化为一个个带有请求 ID 编号的帧，服务器或者浏览器接收到响应帧后，根据相同 ID 帧合并为一条完整信息；
   - 设置请求优先级：发送请求可以设置请求优先级，服务器可以优先处理；
   - 服务器推送：请求一个 HTML 页面，服务器可以知道引用了哪些 JavaScript 和 CSS 文件，附带一起发送给浏览器；
   - 头部压缩：对请求头和响应头进行压缩；
   - **TCP 问题**：如果在传输过程中，有一个数据因为网络故障或者其他原因丢失，那么整个连接会处于暂停状态，只有等到该数据重新传输；

5. HTTP/3
   - HTTP/3 选择了一个折衷的方法，基于现有的 UDP 协议，实现类似 TCP 多路复用，传输可靠等功能，称为 QULC 协议；
   - QULC 实现类似 TCP 流量控制，传输可靠功能；集成 TLS 加密功能；实现多路复用功能；

## HTTPS

1. 在 TCP 和 HTTP 之间插入一个安全层，所有经过安全层的数据都会被加密或者解密；
2. 对称加密：
   浏览器发送加密套件列表和一个随机数 client-random，服务器会从加密套件中选取一个加密套件，然后生成一个随机数 service-random，返回给浏览器。这样浏览器和服务器都有相同 client-random 和 service-random，再用相同的方法将两者混合生成一个密钥 master secret，双方就可以进行数据加密传输了；
   - 缺点：client-random 和 service-random 的过程都是明文，黑客可以拿到协商的加密套件和双方随机数，生成密钥，数据可以被破解；
3. 非对称加密：
   浏览器发送加密套件列表给服务器，服务器选择一个加密套件，返回加密套件和公钥，浏览器用公钥加密数据，服务器用私钥解密；
   - 缺点：加密效率太低；初次通信黑客可以获取公钥。
4. 对称加密结合非对称加密：初次非对称，以后对称；

**注：**2 种加密方式 理论上都可以暴力破解；对称加密破解的概率大点；

## 同源策略：协议、域名和端口号相同的 URL 是同源的

## XSS 攻击(跨站脚本攻击)：为什么 cookie 中有 httpOnly 属性

XSS  攻击是指浏览器中执行恶意脚本, 然后拿到用户的信息进行操作。

- 主要分为存储型、反射型和文档型。

  1. 存储型：(持久型)提交了数据，并且存入了数据库，别人访问这个页面的时候就会自动出发;
  2. 反射型：(非持久型)提交了数据，但是这是对你这次访问产生了影响，并非持久性攻击;
  3. DOM 的：通过 JS 代码对网页进行修改，变化和执行。当 JS 代码执行后的结果产生了 XSS 漏洞的话，这就是 DOM 型 XSS，再根据该 XSS 能否被存储进数据库中，可再细分为反射型和存储型;

- 防范的措施包括:

  1. 一个信念: 不要相信用户的输入，对输入内容转码或者过滤，让其不可执行。
  2. 两个利用: 利用 CSP（只允许页面向允许的域名发起跨域请求）；利用 Cookie 的 HttpOnly 属性。

## CSRF 攻击（跨站请求伪造）：陌生连接不要随便点

- CSRF 攻击攻击原理及过程如下：

  1. 用户打开浏览器，访问受信任网站 A，输入用户名和密码请求登录网站 A；
  2. 用户信息通过验证后，网站 A 产生 Cookie 信息并返回给浏览器，此时用户登录网站 A 成功，可以正常发送请求到网站 A；
  3. 用户未退出网站 A 之前，在同一浏览器中，打开一个 TAB 页访问网站 B；
  4. 网站 B 接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点 A；
  5. 浏览器在接收到这些攻击性代码后，根据网站 B 的请求，在用户不知情的情况下携带 Cookie 信息，向网站 A 发出请求。网站 A 并不知道该请求其实是由 B 发起的，所以会根据用户的 Cookie 信息以用户的权限处理该请求，导致来自网站 B 的恶意代码被执行。

- demo:

  1. git 请求：

     ```code
     <img src="http://www.study.com/admin/resetPassword?id=1" />
     ```

  2. post 请求：

     ```code
        <body>
           <form action="https://vulnerable-website.com/email/change" method="POST">
              <input type="hidden" name="email" value="pwned@evil-user.net" />
              </form>
           <script>
              document.forms[0].submit();
           </script>
        </body>
     ```

- 防范措施：

  1. 随机化 Token（CSRF Token）：Token 是用于验证网站请求者身份的一种机制，可以防止 CSRF 攻击。该 Token 会在每次访问页面时刷新，以确保每次请求都需要新的 Token。
  2. Cookie SameSite 属性：应用于 Cookie，防止跨站请求伪造攻击，避免恶意网站使用认证（sso）cookie 访问目标网站或者欺骗 cookie 窃取用户数据。
  3. 限制 cookies 操作：不能在 cookie 中加入用户敏感信息，避免 cookie 的信息外泄。
  4. 验证请求的来源站点，请求头中的 Referer 和 Origin 属性

**XSS 与 CSRF 的区别**：XSS 是直接盗取到了用户的权限，然后实施破坏，而 CSRF 是借用户的权限完成攻击，攻击者并没有拿到用户的权限。

## 默认浏览器、手机 webview 内核、各家小程序的运行环境

H5 页面：运行环境 1、浏览器；2、APP 的 web-view 组件；3、小程序提供的 web-view 组件；
微信小程序：运行环境是非完整的浏览器，是基于浏览器内核完全重构的一个内置解析器，针对小程序专门做了优化（功能和流畅性更好）

## JQ 中类似 promise

// $.when().done().fail().then()

## JQ 中 prop 和 attr 的区别

prop 方法: 对于元素本身就带有的固有属性
attr 方法: 对于元素我们自己自定义的 DOM 属性

## 进程、线程：参考 计算机基础系列 / 进程-线程-协程-纤程

## 迭代与递归

迭代：for 循环 ；
递归：调用自身或 间接调用自身 ；
递归中一定有迭代，但是迭代中不一定有递归；
能用迭代的不用递归；递归调用函数，浪费空间，并且递归太深容易造成堆栈的溢出。

## 排序：参考计算机基础系列 / 数据结构与算法

## RegExp 对象方法

RegExpObject.exec(string) // 匹配到，返回值，否则返回 null。

RegExpObject.test(string) // 匹配到，返回 true ，否则返回 false。

## AMD/CMD/CommonJs/ES6

1. AMD---Asynchronous Module Definition（异步模块定义）， 特点是：依赖前置
2. CMD---Common Module Definition（通用模块定义），特点是：依赖就近，同步。
3. CommonJs 规范，module.exports / require，特点是 : nodeJs 后台采用的规范，可以多次加载，只在第一次运行，结果被缓存；
4. ES6 特性 export / import，特点是：成对出现. 只有导出才能导入。
