## http2.0

- 多个请求复用（例如：靠近的 2 个请求打包一起发，1 个阻塞另一个还能回来）；
- 防止对头阻塞（请求排队）；
- 压缩 HTTP 头部；
- 服务端推送（服务端发送 index 时，预测用到的 js,css 发送回去）

**注：**不需要 1.雪碧图；2.js/css 合并；  
需要：1/GZIP 压缩；2.首屏优化

## Http3.0

http1.1/http2.0 ------|--------- http3.0
----------------------|--------- QUIC(谷歌出的优化)
-----TCP--------------|----------- UDP-------
--------------网络层-----------------------
--------------连接层-----------------------
--------------物理层-----------------------

## TCP vs UDP

UDP 好处：(不需要 3 次握手，直接发)

- 不需要建立连接；
- 封包体积更小
- 不关心数据顺序（不需要序号和 ACK）
- 不保证数据不丢失

## https

https：在 http 与 TCP/IP 之间增加了 TSL/SSL 层（ HTTP --> TSL/SSL --> TCP/IP ）

**运作方式：**

- SSL：安全套接层
- TSL：传输层安全协议(更安全些)
- 需要客户端安装证书；

  1.企业生成--非对称加密的（公钥 A 、私钥 B）和对称加密的 （I、J、K）;
  企业自己生成的私有证书(公钥 A)----发送--->公信力组织----组织的私钥 签名（加密）------>加过密的签名（C）---->返回给企业；

2. 客户端请求 3 次握手后（此时不用证书加密），服务端将签过名的证书（C）发给客户端；
3. 客户端用“公信力组织的公钥（D）”解密证书（C），核对证书（C）是不是组织发布的；
4. 不是：完结； 是：将证书（C）中的公钥（A）拿出来，加密数据（协商用哪个对称加密证书- I、J、K ）发给服务器，服务器用私钥（B）解密；
5. 私钥(B)解密失败：完结；成功，通信
   ![HTTPS流程](./img/httpSProcess.png)

- 证书：有公信力的组织颁布；（只当裁判，不踢球）
- 对称加密：客户端与服务端用同样的密钥加密解密；（例如：一把锁，两把钥匙）
- 非对称加密：公钥/私钥（一个只负责加密，一个只负责解密；不能都是“加密”或都是“解密”）
  公钥：公开的，每个人能可以用（可以负责加密，也可以负责解密--只能选择一种）  
  私钥：服务端（公司，组织）私有的（可以负责加密，也可以负责解密--只能选择一种）

**注：**2 种加密方式 理论上都可以暴力破解；对称加密破解的概率大点；

## 状态码

- 301: 永久转移（和 308 对应；post 变 get）；
- 308: 永久重定向（和 301 对应；post 还是 post，不会变 get）；

- 302: Found 资源被找到-临时（以前是临时转移）--不建议使用；被拆成（303，307）;
- 303:（替代原来的 302）浏览器看到 303 自动用 get 跳转到对应的临时资源；（post 变 get）
- 307:（替代原来的 302）临时重定向（post 还是 post，不会变 get）；

- 304：资源没有修改（不返回资源，用缓存）；

## WebSocket

```
const client =new WebSocket("ws://chat.svc");

测试用 ws; 上线用 wss
ws -----> WebSocket 缩写
wss ----> WebSocket Secure（加密）
wss ----> tls-tcp/ip
https --> tls/ssl -->tcp/ip
```

1. WebSocket:握手和协议转换的过程很【自然】
2. socket(网络插座)：为客户端/服务端提供通信机制
