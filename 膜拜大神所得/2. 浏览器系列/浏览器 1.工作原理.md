# 浏览器内核分成两部分：渲染引擎和 JS 引擎

渲染引擎:是一种对 HTML 文档进行解析并将其显示在页面上的工具。（说白了，就是按照 HTML 代码在界面上绘制各种控件图形）

- 线程和进程:

  1. 一个进程包含一个或多个线程；
  2. 当一个进程关闭后，操作系统会回收进程所占用的内存;
  3. 进程之间的内容相互隔离;

  4. 线程不能单独存在，它是由进程来启动和管理的;
  5. 多线程可以并行处理任务;
  6. 线程之间共享进程中的数据;
  7. 任意一线程执行出错，都会导致整个进程的崩溃;

- 当我们启动一个应用，计算机会创建一个进程，操作系统会为进程分配一部分内存，应用的所有状态都会保存在这块内存中，应用也许还会创建多个线程来辅助工作，这些线程可以共享这部分内存中的数据。如果应用关闭，进程会被终结，操作系统会释放相关内存。

- 一个进程还可以要求操作系统生成另一个进程来执行不同的任务，系统会为新的进程分配独立的内存，两个进程之间可以使用 IPC （Inter Process Communication）进行通信。很多应用都会采用这样的设计，如果一个工作进程反应迟钝，重启这个进程不会影响应用其它进程的工作。

## 浏览器的工作原理 [原文链接](https://zhuanlan.zhihu.com/p/47407398)

- 单进程浏览器:

  1. 不稳定。单进程中的插件、渲染线程崩溃导致整个浏览器崩溃。
  2. 不流畅。脚本（死循环）或插件会使浏览器卡顿。
  3. 不安全。插件和脚本可以获取到操作系统任意资源。

- 多进程浏览器:

  1. 解决不稳定。进程相互隔离，一个页面或者插件崩溃时，影响仅仅时当前插件或者页面，不会影响到其他页面。
  2. 解决不流畅。脚本阻塞当前页面渲染进程，不会影响到其他页面。多进程充分利用多核优势
  3. 解决不安全。采用多进程架构使用沙箱。 沙箱看成时操作系统给进程上来一把锁，沙箱的程序可以运行，但是不能在硬盘上写入任何数据，也不能在敏感位置读取任何数据。(页面 A 的渲染、插件进程 放一个沙箱，页面 B 的渲染、插件进程 放一个沙箱)
  4. 缺点：1、资源占用高。2、体系架构复杂。

多进程浏览器：由多个进程组成，每个进程都有自己核心的职责，它们相互配合完成浏览器的整体功能；每个进程中又包含多个线程，一个进程内的多个线程也会协同工作，配合完成所在进程的职责。(浏览器就相当于一个工厂；进程相当于一个车间；线程相当于车间内的一个个员工，可以自己做自己的事情，也可以相互配合做同一件事情；一个工厂可以有多个车间，浏览器可以有多个进程)

### Chrome 的主要进程及其职责

浏览器进程(1 个)、GPU 进程(1 个)、网络进程(1 个)、渲染进程(多个)、插件进程(多个)

每个 tab 标签页的 “渲染进程”和“插件进程”放一个沙箱中；

Chrome 采用多进程架构，其顶层存在一个 “浏览器进程”(Browser Process) 用以协调浏览器的其它进程。
Chrome 浏览器的每个标签（tab）都分别对应一个渲染引擎实例。每个标签（tab）都是一个独立的进程（渲染进程）。

1. 浏览器进程(Browser Process) ：（只有一个，负责协调、主控）

   - 负责浏览器界面显示(标签页外除)，与用户交互。包括地址栏，书签栏，前进后退按钮等部分的工作
   - 负责与其他进程的协调工作，同时提供存储功能。
   - 负责各个页面的管理，创建和销毁其他进程。
   - 将 Renderer 进程得到的内存中的 Bitmap（位图），绘制到用户界面上

2. 渲染进程(Renderer Process)：

   - 负责控制显示 tab 标签页内的所有内容，核心任务是将 HTML、CSS、JS 转为用户可以与之交互的网页，
   - 排版引擎 Blink/Webkit 和 JS 引擎 V8 都是运行在该进程中，
   - 默认情况下 Chrome 会为每个 Tab 标签页创建一个渲染进程。如果 2 个页面属于同一站点，并且从 a 页面中打开 b 页面，那么他们也会共用一个渲染进程，否则新开一个渲染进程

   包含：

   - GUI 渲染线程：
     GUI 渲染线程负责渲染浏览器界面 HTML 元素,当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时，该线程就会执行。在 Javascript 引擎运行脚本期间,GUI 渲染线程都是处于挂起状态的，也就是说被冻结了。

   - JavaScript 引擎线程：
     这就是我们常说的 js 单线程，主要是为了实现 JS 文件的解析和运行，包括执行用户的交互操作、dom 树修改、css 样式更新等操作。需要注意的是若 js 执行过程会导致 GUI 渲染线程阻塞，它们不可同步执行.

   - 定时触发器线程：
     浏览器定时计数器（setTimeout、setInterval ）并不是由 JS 引擎计数的, 因为 JS 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。

   - 异步 Http 请求线程：
     在 XMLHttpRequest 连接后,通过浏览器新开一个线程请求，将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JS 引擎的处理队列中等待处理。

   - 事件触发线程
     事件处理线程管理着任务队列，异步任务的回调函数会放在其中，等 执行栈中的任务执行完毕后，读取其中任务执行。如鼠标点击、滑动、异步 http 请求等的回调处理。

3. GPU 进程(GPU Process)：用于硬件加速图形绘制
   负责整个浏览器界面的渲染。Chrome 刚开始发布的时候是没有 GPU 进程的，而使用 GPU 的初衷是为了实现 3D CSS 效果，只是后面网页、Chrome 的 UI 界面都用 GPU 来绘制，这使 GPU 成为浏览器普遍的需求，最后 Chrome 在多进程架构上也引入了 GPU 进程。

4. 网络进程:
   主要负责页面的网络资源加载，以前是作为模块运行在“浏览器进程”里面的，后面才独立出来，成为一个单独的进程。

5. 插件进程(Plugin Process)：
   主要负责插件的运行，因为插件可能崩溃，所以需要通过插件进程来隔离，以保证插件崩溃也不会对浏览器和页面造成影响

   - 负责控制一个网页用到的所有插件，如 flash,
   - 每种类型的插件对应一个进程，仅当使用该插件时才创建

6. 任务管理器

![浏览器主要进程](./img/browser.jpg)

### iframe 的渲染 -- Site Isolation

这种机制允许在同一个 Tab 下的跨站 iframe 使用单独的进程来渲染，这样会更为安全。

**注：** 在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）。如果浏览器是单进程，那么某个 Tab 页或者第三方插件崩溃了，就影响了整个浏览器，体验有多差，而且多进程还有其它的诸多优势，当然，多进程内存等资源消耗也会更大，有点空间换时间的意思。。

#### HTTP 请求流程：为什么很多站点第二次打开速度会很快

浏览器中的 HTTP 请求从发起到结束一共经历如下八个阶段：
构建请求、查找缓存、准备 IP 和端口、等待 TCP 队列、建立 TCP 连接、发起 HTTP 请求、服务器处理请求、服务器返回请求和断开连接；

1. 构建请求。浏览器构建请求行，构建好后，准备发起网络请求；
2. 查找缓存。在真正发起请求前浏览器会查询缓存中是否有请求资源副本，有则拦截请求，返回资源副本，否则进入网络请求；
3. 准备 IP 地址和端口。HTTP 网络请求需要和服务器建立 TCP 连接，而建立 TCP 连接需要准备 IP 地址和端口号，浏览器需要请求 DNS 返回域名对应的 IP，同时会缓存域名解析结果，供下次查询使用；
4. 等待 TCP 队列。Chrome 机制，同一个域名同时最多只能建立 6 个 TCP 连接；
5. 建立 TCP 连接。TCP 通过“三次握手”建立连接，传输数据，“四次挥手”断开连接；
6. 发送 HTTP 请求。建立 TCP 连接后，浏览器就可以和服务器进行 HTTP 数据传输了，首先会向服务器发送请求行，然后以请求头形式发送一些其他信息，如果是 POST 请求还会发送请求体；
7. 服务器处理请求。
8. 服务器返回请求和断开连接。首先服务器会返回响应行(协议版本、状态码、状态描述)，随后，服务器向浏览器发送响应头和响应体。通常服务器返回数据，就要关闭 TCP 连接，如果请求头或者响应头有 Connection:keep-alive TCP 保持打开状态；

#### 导航流程：从输入 URL 到页面展示这中间发生了什么

浏览器 Tab 外的工作主要由 “浏览器进程”(Browser Process) 掌控,分为:

1. 用户输入 URL 并回车。
2. “浏览器进程”检查 URL，组装协议，构成完整 URL。
3. “浏览器进程”通过进程通信（IPC）把 URL 请求发送给“网络进程”，并控制 tab 上的 spinner 展现，表示正在加载中。
4. “网络进程”接收到 URL 请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程。
5. 如果没有，“网络进程”向 web 服务器发起 http 请求（网络请求），请求流程如下：

   - 进行 DNS 解析，获取服务器 IP 地址，端口；
   - 利用 IP 地址和服务器建立 tcp 连接；
   - 构建请求头信息；
   - 发送请求头信息；
   - 服务器响应后，网络进程接收响应头和响应信息，并解析响应内容；

6. “网络进程”解析响应流程：

   - 检查状态码，如果是 301/302，则需要重定向，从 Location 自动读取地址，重新进行第 4 步，如果是 200，则继续处理请求
   - 200 响应处理：检查响应类型 Content-Type，
     如果是字节流类型（zip、pdf 等），则将该请求提交给下载管理器，该导航流程结束，不再进行后续渲染。
     如果是 html 则通知“浏览器进程”准备“渲染进程”进行渲染；
     (Safe Browsing（安全浏览） 检查也会在此时触发，如果域名或者请求内容匹配到已知的恶意站点，“网络进程” 会展示一个警告页)  
     (此外 CORB 检测也会触发确保敏感数据不会被传递给渲染进程)

7. 准备“渲染进程”

   - “浏览器进程”检查当前 URL 是否和之前打开的“渲染进程”根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程。
     **注：** 由于网络请求获取响应需要时间，这里其实还存在着一个加速方案。当 “浏览器进程” 发送 URL 请求给 “网络进程” 时，浏览器其实已经知道了将要导航到那个站点。“网络进程” 会并行的预先查找和启动一个渲染进程，  
      如果一切正常，当 network thread 接收到数据时，渲染进程已经准备就绪了，  
      但是如果遇到重定向，准备好的渲染进程也许就不可用了，这时候就需要重启一个新的渲染进程。

8. 传输数据、更新状态

   - “渲染进程”准备好后，浏览器向“渲染进程”发起“提交文档”的消息，“渲染进程”接收到消息和“网络进程”建立传输数据的“管道”；
   - “渲染进程”接收完数据后，向浏览器发送“确认提交”；
   - “浏览器进程”接收到“确认消息”后 更新 浏览器界面状态：安全、地址 URL、前进后退的历史状态、更新 web 页面；为了让关闭 tab 或者窗口后便于恢复，这些信息会存放在硬盘中。（导航过程结束，页面加载过程开始）

9. ==================================================================================

10. 额外的步骤：当 renderer process 渲染结束（渲染结束意味着该页面内的所有的页面，包括所有 iframe 都触发了 onload 时），会发送 IPC 信号到 Browser process， Browser process 会停止展示 tab 中的 spinner。当然上面的流程只是网页首帧渲染完成，在此之后，客户端依旧可下载额外的资源渲染出新的视图。  
    **注：** 所有的 JS 代码其实都由 renderer Process 控制的，所以在你浏览网页渲染内容的过程大部分时候不会涉及到其它的进程。  
     不过也许你也曾经监听过 beforeunload 事件，这个事件再次涉及到 Browser Process 和 renderer Process 的交互，当当前页面关闭时（关闭 Tab ，刷新等等），Browser Process 需要通知 renderer Process 进行相关的检查，对相关事件进行处理。  
     如果导航由 renderer process 触发（比如在用户点击某链接，或者 JS 执行 `window.location = "http://newsite.com" ` ） renderer process 会首先检查是否有 `beforeunload` 事件处理器，导航请求由 renderer process 传递给 Browser process；  
     如果导航到新的网站，会启用一个新的 render process 来处理新页面的渲染，老的进程会留下来处理类似 `unload` 等事件。

**例外：** Service Worker （服务工作线程）  
如果 Service Worker 被设置为从本地 cache 中加载数据，那么就没有必要从网上获取更多数据了；service worker 也是运行在渲染进程中的 JS 代码，因此对于拥有 Service Worker 的页面，上述流程有些许的不同。  
当有 Service Worker 被注册时，其作用域会被保存，当有导航时，network thread 会在注册过的 Service Worker 的作用域中检查相关域名，

- 如果存在对应的 Service worker，UI thread 会找到一个 renderer process 来处理相关代码，Service Worker 可能会从 cache 中加载数据，从而终止对网络的请求，也可能从网上请求新的数据。
- 如果 Service Worker 最终决定通过网上获取数据，Browser 进程 和 renderer 进程的交互其实会延后数据的请求时间 。Navigation Preload 是一种与 Service Worker 并行的加速加载资源的机制，服务端通过请求头可以识别这类请求，而做出相应的处理。
