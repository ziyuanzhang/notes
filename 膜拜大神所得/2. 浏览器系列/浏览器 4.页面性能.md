# 页面性能

页面性能是指网页的加载速度和响应性能。

常用的页面性能指标包括:总阻塞时间、首次内容绘制时间、DOMContentLoaded 时间、完全加载时间等。

- 总阻塞时间：
  1. 资源加载阻塞：当浏览器下载页面所需的资源（如 CSS、JavaScript、图片等）时，如果资源的大小较大或者服务器响应缓慢，会导致页面加载速度变慢，从而增加总阻塞时间。
  2. 脚本执行阻塞：当浏览器执行 JavaScript 脚本时，如果脚本较长或者执行过程中有耗时的操作，会阻塞页面的渲染和响应，增加总阻塞时间。
  3. 渲染阻塞：当浏览器在解析 HTML 和 CSS 样式时，如果遇到复杂的布局或者样式嵌套，会导致页面渲染时间较长，增加总阻塞时间。
  4. 网络请求阻塞：当网页需要向服务器发送请求获取数据时，如果网络连接较慢或者服务器响应缓慢，会导致请求时间延迟，从而增加总阻塞时间。

## a

任何运行时间超过 50 毫秒的任务都被视为“长任务”。

50 毫秒基准基于以下条件确认的：设备必须每 16 毫秒 (60 fps) 创建一个新帧才能保持流畅的视觉体验。然而，设备还必须执行其他任务，例如响应用户输入和执行 JavaScript。50ms 基准测试允许设备将资源分配给渲染帧和执行其他任务，并为设备提供约 33.33ms 的额外时间来执行其他任务，同时保持流畅的视觉体验。

## 页面性能：如何系统优化页面

https://blog.csdn.net/qq_46143850/article/details/139323557

一个页面有三个阶段：加载阶段、交互阶段和关闭阶段。

1. 加载阶段：

   - 减少关键资源个数; （超小的 js/css 内联；js 不操作 dom/css 用 async/defer 属性，css 媒体选择器取消加载）
   - 降低关键资源大小;（压缩；移除注释）
   - 降低关键资源的 RTT（Round Trip Time） 次数;（减少个数；减少大小；CDN）

     那什么是 RTT 呢？（当使用 TCP 协议传输一个文件时，比如这个文件大小是 0.1M，由于 TCP 的特性，这个数据并不是一次传输到服务端的，而是需要拆分成一个个数据包来回多次进行传输的。RTT 就是这里的往返时延。它是网络中一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认，总共经历的时延。通常 1 个 HTTP 的数据包在 14KB 左右，所以 1 个 0.1M 的页面就需要拆分成 8 个包来传输了，也就是说需要 8 个 RTT。

     我们可以结合上图来看看它的关键资源请求需要多少个 RTT。首先是请求 HTML 资源，大小是 6KB，小于 14KB，所以 1 个 RTT 就可以解决了。至于 JavaScript 和 CSS 文件，这里需要注意一点，由于渲染引擎有一个预解析的线程，在接收到 HTML 数据之后，预解析线程会快速扫描 HTML 数据中的关键资源，一旦扫描到了，会立马发起请求，你可以认为 JavaScript 和 CSS 是同时发起请求的，所以它们的请求是重叠的，那么计算它们的 RTT 时，只需要计算体积最大的那个数据就可以了。这里最大的是 CSS 文件（9KB），所以我们就按照 9KB 来计算，同样由于 9KB 小于 14KB，所以 JavaScript 和 CSS 资源也就可以算成 1 个 RTT。也就是说，上图中关键资源请求共花费了 2 个 RTT。）

2. 交互阶段（渲染阶段）：尽量减少一帧的生成时间。

   - 减少 js 脚本执行时间。
   - 避免强制同步布局：js 强制将“计算样式”和“布局操作”提前到当前的任务中。
   - 避免布局抖动： 在一段 js 代码中，反复执行布局操作。
   - 合理利用 CSS 合成动画：标记 will-change。
     合成动画是在“合成线程”上执行的；如果主线程被 js 或者一些布局任务占用，CSS 动画依然能继续执行（它不会触发重排或者重绘）。
   - 避免频繁的垃圾回收。

3. 关闭阶段

## 打包阶段

1. 压缩代码：删除多余的代码、注释、简化代码的写法等等⽅式
2. 利⽤ CDN 加速: 在构建过程中，将引⽤的静态资源路径修改为 CDN 上对应的路径。（publicPath）
3. Tree Shaking: 将代码中永远不会⾛到的⽚段删除掉。
4. Code Splitting: 将代码按路由维度或者组件分块(chunk),这样做到按需加载,同时可以充分利⽤浏览器缓存
5. 提取公共第三⽅库: SplitChunksPlugin 插件来进⾏公共模块抽取,利⽤浏览器缓存可以⻓期缓存这些⽆需频繁变动的公共代码

6. 多⼊⼝情况下，使⽤ CommonsChunkPlugin 来提取公共代码
7. 利⽤ DllPlugin 和 DllReferencePlugin 预编译资源模块通过 DllPlugin 来对那些我们引⽤但是绝对不会修改的 npm 包来进⾏预编译，再通过 DllReferencePlugin 将预编译的模块加载进来。
8. 使⽤ Happypack 实现多线程加速编译
9. 使⽤ webpack-uglify-parallel 来提升 uglifyPlugin 的压缩速度。原理上 webpack-uglify-parallel 采⽤了多核并⾏压缩来提升压缩速度
