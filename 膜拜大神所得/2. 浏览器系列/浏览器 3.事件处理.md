## 浏览器对事件的处理 [原文链接](https://zhuanlan.zhihu.com/p/47407398)

在浏览器的看来，用户的所有手势都是输入，鼠标滚动，悬置，点击等等都是。

用户在屏幕上操作，首先收到信息的是 Browser process（不过 Browser process 只会感知到在哪里发生了手势），事件发生时，浏览器进程会发送事件类型及相应的坐标给渲染进程，渲染进程随后找到事件对象并执行所有绑定在其上的相关事件处理函数。

合成器可以独立于主线程之外通过合成栅格化层平滑的处理滚动

- 如果页面中没有绑定相关事件，组合器线程可以独立于主线程创建组合帧。
- 如果页面绑定了相关事件处理器，主线程就不得不出来工作了。
  这里涉及到一个专业名词「理解非快速滚动区域（non-fast scrollable region）」由于执行 JS 是主线程的工作，当页面合成时，合成器线程会标记页面中绑定有事件处理器的区域为 non-fast scrollable region ，如果存在这个标注，合成器线程会把发生在此处的事件发送给主线程，如果事件不是发生在这些区域，合成器线程则会直接合成新的帧而不用等到主线程的响应。

web 开发中常用的事件处理模式是事件委托，基于事件冒泡,把委托层变成了「理解非快速滚动区域（non-fast scrollable region）」；
这意味着即使操作的是页面无绑定事件处理器的区域，每次输入时，合成器线程也需要和主线程通信并等待反馈，流畅的合成器独立处理合成帧的模式就失效了。

#### 事件的优化

一般我们屏幕的刷新速率为 60fps，但是某些事件的触发量会不止这个值，出于优化的目的，Chrome 会合并连续的事件(如 wheel, mousewheel, mousemove, pointermove, touchmove )，并延迟到下一帧渲染时候执行 。

而如 keydown, keyup, mouseup, mousedown, touchstart, 和 touchend 等非连续性事件则会立即被触发。

合并事件虽然能提示性能，但是如果你的应用是绘画等，则很难绘制一条平滑的曲线了，此时可以使用 `getCoalescedEvents` API 来获取组合的事件。
