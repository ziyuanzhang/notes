## 事件循环机制 -- nodeJS 端（由 libuv 库实现） [原文链接](https://zhuanlan.zhihu.com/p/35918797)

**重要重要：**

1.  事件循环机制由宿主环境实现, js 引擎（V8）只负责执行代码；
2.  事件循环机制有多个队列参与（多个）；任务队列是一组任务（task）

把“JS 引擎源码"编辑成文件,作为库引进 C 中，异步则执行死循环挂起，回调

![node事件循环](./img/nodeEventLoop.jpg)

- 图片中的不同的盒子代表不同的阶段，每个阶段执行特定的工作。每个阶段都有一个队列，Javascript 可以在任何一个阶段执行（除了 idle & prepare）。
- 你在图片中也能看到 nextTickQueue 和 microTaskQueue，它们不是循环的一部分，它们的回调可以在任意阶段执行。它们有更高的优先级去执行。

### 事件循环的工作流程

1. 当在你的控制台运行 node my-script.js，node 设置事件循环然后运行你主要的模块（my-script.js） 事件循环的外部。
2. 一旦主要模块执行完，node 将会检查循环是否还活着（事件循环中是否还有事情要做）？
3. 如果没有，将会在执行退出回调后退出，process.on('exit', foo) 回调（退出回调）。
4. 但是如果循环还活着，node 将会从计时器阶段进入循环。

#### 定时器（Timer）阶段 --- （setTimeout, setInterval）

A-->B-->C-->D-->E-->F
事件循环进入定时器阶段，检查是否有需要执行的；（这阶段有系统限制，达到系统最大限制数量，即使有未执行的回调也跳到下一阶段）  
例如：先检查 A，A 在执行时间内，执行 A 的回调；再检查 B 依次类推；如果 C 不在执行时间内，则不执行 C 的回调，停止 D 的检查；

#### 即将发生的（Pending）i/o 回调（callback）阶段 --- 上一轮循环中少数 callback/Io 会被延迟到这一阶段执行

事件循环进入即将发生的 i/o 阶段，检查“对应队列”中是否有即将发生的任务的回调；有一个接一个执行，直到队列为空或者达到系统的最大限制；

#### 空闲（Idle），准备（Prepare）阶段

Idle：libuv 一些内部操作；Prepare：在 I/O 轮询之前的一些准备工作;这两个阶段是 node 主要做一些内部操作的阶段

#### 轮询（Poll）阶段 --- 处理 I/O 回调及选择性地等待 I/O 操作

这是一个观察的阶段；这个阶段接受新传入的连接（新的 Socket 建立，http 连接等）和数据（文件读取等）。

- 如果 watch_queue 不为空，它们将会被一个接着一个的执行直到队列为空或者系统到达最大的限制；
- 一旦队列为空，node 就会等待新的连接；等待（睡眠）的时间取决于多种因素。
  **注意：**检查队列（check queue），即将发生的队列（pending queue），或者关闭队列（closing callbacks queue 或者 idle handler queue）里面有任何任务在等待，它将等待 0 毫秒。

#### 检查（Check）阶段 --- 主要处理 setlmmediate 的回调

它将会像其他阶段那样一个接着一个的执行，直到队列为空或者达到依赖系统的最大限制。

#### 关闭（Close）回调 --- 处理所有的关闭 I/O 回调

- 回调的关闭(socket.on(‘close’, ()=>{})) 都在这里处理的，更像一个清理阶段;
- 这个阶段的队列执行完后，会检查“事件循环”是否还活着，如果没有则退出；如果还有工作要做，它会进行下一个循环；
- 因此在定时器阶段：如果前面的定时器 A,B 执行过了，侧从 C 开始检查

#### nextTickQueue & microTaskQueue --- 当前阶段到下一个阶段之前 触发

不是在 libUV 中开发的，而是在 node.js 中
nextTickQueue：存储着 process.nextTick() 的回调；  
microTaskQueue：存储着 Promise 的回调;  
nextTickQueue 的优先级高于 microTaskQueue。

#### 进程池（Thread-pool）

nodejs 没有进程池，进程池是 libUV 库中的（nodejs 用来处理异步的第三方库）；并不是每个异步任务被进程池所处理的；  
libUv 能够灵活地使用操作系统的异步 apis 来保持环境为事件驱动。然而操作系统的 api 不能做文件读取，dns 查询等，这些由进程池所处理。
