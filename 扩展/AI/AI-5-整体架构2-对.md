# AI-5-整体架构 2-对

```bash
用户问题
 ↓
FastAPI
 ↓
LangChain Agent
 ↓（判断需要查资料）
fastMCP → ragflow_search
 ↓
RAGFlow 检索
 ↓
返回上下文
 ↓
LangChain 组合 Prompt
 ↓
vLLM 生成答案
 ↓
返回用户

```

- 好处

  - ✔ 解耦

    1. Agent 不绑定 RAGFlow
    2. RAGFlow 不知道 Agent 存在

  - ✔ 可扩展

  fastMCP 后面可以加：

  1. DB Tool
  2. 搜索 Tool
  3. 工单 / CRM Tool

  - ✔ 企业友好
    - 无 LangSmith 依赖
    - 全私有化
    - 标准 HTTP + Tool 协议

## 一、100% 正确的 Agent-First 架构（完整版）

```pgsql
┌──────────────────────────────────────────────────┐
│                  Interaction Plane               │
│        Web · App · n8n · System · Schedule       │
└──────────────────────┬───────────────────────────┘
                       ▼
┌──────────────────────────────────────────────────┐
│                 Agent Gateway                    │
│  API / Auth / RateLimit / Session / Audit        │
│  ──────────────────────────────────────────────  │
│  ❗ 唯一入口 / 不含推理                             │
└──────────────────────┬───────────────────────────┘
                       ▼
┌──────────────────────────────────────────────────┐
│              Agent Control Plane                 │
│        (Reasoning & Decision Authority)          │
│  ┌────────────────────────────────────────────┐  │
│  │ Planner / Policy / Intent                  │  │
│  │ Executor (LangGraph Runtime)               │  │
│  │ Observe / Reflect / Retry                  │  │
│  │ State / Memory                             │  │
│  └────────────────────────────────────────────┘  │
│  ❗ 全系统唯一“决策权威”                            │
└──────────────────────┬───────────────────────────┘
                       ▼
┌──────────────────────────────────────────────────┐
│              Tool Control Plane                  │
│                 (Governance)                     │
│  Tool Registry / Schema / ACL / Budget / SLA     │
│  Timeout / Retry / Fallback                      │
│  ❗ 工具永远是被控对象                              │
└──────────────────────┬───────────────────────────┘
                       ▼
┌──────────────────────────────────────────────────┐
│                Tool Data Plane                   │
│  Knowledge · DB · Search · Actions · Systems     │
│  ❗ 无推理 / 无状态 / 无上下文                      │
└──────────────────────┬───────────────────────────┘
                       ▼
┌──────────────────────────────────────────────────┐
│                Model Plane                       │
│  Reasoning / Generation / Embedding / Rerank     │
└──────────────────────────────────────────────────┘

```

- Interaction Plane → Agent Gateway → Agent Control Plane → Tool Control Plane → Tool Data Plane → Model Plane → 回传 Agent Control Plane → Agent Gateway → 用户

- 用户请求 → 代理网关 → 代理控制 → 工具控制 → 工具数据 → 模型 → 回传 代理控制 → 代理网关 → 用户

- 请求生命周期

  1. 用户请求通过 Interaction Plane 发起，进入 Agent Gateway。
  2. Agent Gateway 校验权限、上下文并记录日志。
  3. Agent Control Plane 进行推理：

     - 判断是否需要知识库查询（Policy Check）
     - 多步调用工具（Multi-Step Loop）
     - 观察工具返回并反思（Observation / Reflection）

  4. Tool Control Plane 负责治理工具调用：

     - 检查 ACL、预算、超时
     - 调用具体 Tool（RAGFlow / DB / API）

  5. Tool Data Plane 执行实际操作并返回结果。
  6. Agent Control Plane 根据 Observation 决策下一步操作，或生成最终答案。
  7. Agent Gateway 统一返回结果给用户。
  8. 整个执行过程可审计并记录日志，可 replay。

### 100% 正确架构的 5 个“硬条件”

1. ① 决策权「不可旁路」
2. ② Agent Policy 是“第一等公民”
3. ③ Tool 治理是显式的
4. ④ Agent 是“可审计系统”，不是黑盒
5. ⑤ Agent 可以被“替换而系统不崩”

### 100% 正确架构 ≠ 复杂架构

- 它的核心特征不是复杂，而是：
  1. 权力集中
  2. 责任单一
  3. 边界清晰
  4. 治理先行

### 100% 正确架构的「判定清单」（自检）

- 如果下面 全部 YES，就是 100%：
  1. 所有请求是否只能通过 Agent？
  2. Agent 是否拥有是否用 RAG 的裁决权？
  3. Tool 是否完全无状态、无推理？
  4. 是否存在明确的 Agent Policy 层？
  5. Tool 是否有 Schema / ACL / Budget？
  6. Agent 行为是否可回放 / 审计？
  7. 是否能无痛替换 Agent Runtime？

## 二、最后 30% 的落地清单（Checklist）

| 模块                      | 任务                               | 说明                                                | 完成标准                              |
| ------------------------- | ---------------------------------- | --------------------------------------------------- | ------------------------------------- |
| 入口网关（Agent Gateway） | 禁止绕过                           | 任何系统、用户、调度器都必须通过 Agent              | 网关日志可验证所有请求都走 `/agent/*` |
| Agent Policy 层           | 权限控制                           | 用户/角色/成本/Tool 限制                            | policy config + enforcement 代码生效  |
| Tool 管理                 | Schema / ACL / Budget / Timeout    | 所有工具通过 fastMCP 或类似治理                     | 调用失败、超时、权限限制生效          |
| Agent 可审计              | Observe / Action / Decision 可追踪 | 日志记录中间决策、调用工具、LLM 响应                | 可以 replay / 回放每一次 Agent 执行   |
| 可替换 Agent Runtime      | 与工具层解耦                       | Agent 可替换为 LangGraph / 自研 Runtime，不影响工具 | 测试替换 Agent Runtime，系统行为一致  |
| Multi-Step Loop           | Observe / Reflect / ReAct          | Agent 可以多步调用工具                              | 通过多轮 RAG 查询 + 推理成功          |
| Replay / 回放             | 存储状态                           | 每次 Agent 运行结果、observations、actions 可存     | 能够加载历史状态重演推理              |

## 三、补齐这 30% 的成果

1. 入口安全：所有请求必须经过 Agent Gateway
2. Agent Policy 层：权限/调用次数/超时/重试
3. Tool 管理：fastMCP + Schema + Governance
4. 可审计：日志 + replay
5. 多步循环：Observe / Reflect / ReAct
6. Agent 可替换：LangGraph / 自研 Runtime

- ✅ 满足企业级生产要求
- ✅ 完成 100% 正确 Agent-First 架构

## 四、代码模板（Python + FastAPI + LangGraph + fastMCP）

1. 1️⃣ Agent Policy 配置

   ```python
   # app/policy.py
   POLICIES = {
       "rag_search": {
           "roles": ["admin", "user"],
           "max_calls_per_request": 2,
           "timeout_sec": 10,
           "allow_retries": 1
       },
       "internal_api": {
           "roles": ["admin"],
           "timeout_sec": 5
       }
   }

   def check_policy(tool_name: str, role: str, calls: int):
       policy = POLICIES.get(tool_name)
       if not policy:
           raise PermissionError(f"No policy for tool {tool_name}")
       if role not in policy["roles"]:
           raise PermissionError(f"Role {role} cannot use {tool_name}")
       if calls > policy.get("max_calls_per_request", 1):
           raise PermissionError(f"Exceeded max calls for {tool_name}")
       return policy

   ```

2. 2️⃣ fastMCP 工具调用封装（治理层）

   ```python
   # app/tools/mcp_client.py
   import asyncio
   from fastmcp import Client
   from app.policy import check_policy

   mcp_client = Client("http://mcp-server:9000")

   async def call_tool(tool_name: str, input: dict, role: str, call_count: int = 1):
       policy = check_policy(tool_name, role, call_count)
       # 处理 timeout / retry
       timeout = policy.get("timeout_sec", 10)
       retries = policy.get("allow_retries", 0)
       for attempt in range(retries + 1):
           try:
               async with mcp_client:
                   result = await mcp_client.call_tool(tool_name, input)
                   return result
           except Exception as e:
               if attempt == retries:
                   raise e

   ```

3. 3️⃣ Agent 可审计节点执行

   ```python
   # app/agent_observe.py
   from datetime import datetime
   import json

   LOG_FILE = "agent_execution.log"

   def log_execution(node_name: str, input_data: dict, output_data: dict):
       record = {
           "timestamp": datetime.utcnow().isoformat(),
           "node": node_name,
           "input": input_data,
           "output": output_data
       }
       with open(LOG_FILE, "a") as f:
           f.write(json.dumps(record, ensure_ascii=False) + "\n")

   ```

4. 4️⃣ 多步循环示例（LangGraph）

   ```python
   # app/graph_loop.py
   from langgraph.graph import StateGraph, END
   from app.state import AgentState
   from app.nodes import decide_need_knowledge, call_rag, final_answer
   from app.agent_observe import log_execution

   builder = StateGraph(AgentState)
   builder.add_node("decide", decide_need_knowledge)
   builder.add_node("rag", call_rag)
   builder.add_node("final", final_answer)

   def route(state: AgentState):
       return "rag" if state.get("need_knowledge") else "final"

   builder.add_conditional_edges("decide", route, {"rag": "rag", "final": "final"})
   builder.add_edge("rag", "final")
   builder.add_edge("final", END)

   # 包装日志
   graph = builder.compile(log_func=log_execution)

   ```

5. 5️⃣ 最终请求执行（FastAPI）

   ```python
   # app/main.py
   from fastapi import FastAPI
   from pydantic import BaseModel
   from app.graph_loop import graph

   app = FastAPI(title="Agent Gateway 100% 完整架构")

   class AskReq(BaseModel):
       input: str
       context: dict | None = None
       role: str = "user"

   @app.post("/agent/ask")
   async def ask(req: AskReq):
       state = {
           "input": req.input,
           "context": req.context or {},
           "role": req.role
       }
       result = graph.invoke(state)
       return {"answer": result["final"]}

   ```

##

Interaction Plane → Agent Gateway → Agent Control Plane → Tool Control Plane → Tool Data Plane → Model Plane → 回传 Agent Control Plane → Agent Gateway → 用户
