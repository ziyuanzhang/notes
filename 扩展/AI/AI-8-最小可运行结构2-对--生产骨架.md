# AI-8-最小可运行结构 2-对 -- 生产骨架

在上一步（不推翻刚才 MVP） 的前提下，逐步升级成：fastMCP + RAGFlow + vLLM 的真实可运行生产骨架。

- 严格遵守三条原则：

  1. Agent 不变（控制面稳定）
  2. RAGFlow 降级为 Tool（不可直连）
  3. vLLM 只是模型平面（无业务）

## 一、升级后的「最小但真实」结构

```bash

agent-gateway/
├─ app/
│  ├─ main.py
│  └─ api_agent.py
│
├─ agents/
│  ├─ graph.py
│  └─ state.py
│
├─ policies/
│  └─ tool_policy.py
│
├─ tools/
│  ├─ mcp_client.py        # fastMCP Client（治理入口）
│  └─ ragflow_tool.py     # RAGFlow Tool Adapter
│
└─ models/
   └─ llm.py               # vLLM Client

```

## 二、代码

### 1、Tool Control Plane：fastMCP Client（关键升级）

- 这里是真正的 Tool Control Plane
- fastMCP = 工具治理，不是 Agent

```python
# tools/mcp_client.py
from fastmcp import Client
from policies.tool_policy import check_tool_policy

MCP_ENDPOINT = "http://127.0.0.1:9000"

async def call_tool(
    tool_name: str,
    payload: dict,
    state: dict
):
    # 1. Policy enforcement（补齐 30% 的核心）
    check_tool_policy(tool_name, state)

    # 2. Tool 治理入口
    client = Client(MCP_ENDPOINT)
    async with client:
        result = await client.call_tool(tool_name, payload)

    return result

```

### 2、RAGFlow Tool（彻底 Tool 化）

注意这里的地位变化：

- ❌ RAGFlow：入口 / Agent
- ✅ RAGFlow：被 Agent 调用的 Tool

```python
# tools/ragflow_tool.py
from tools.mcp_client import call_tool

async def rag_search(query: str, state: dict) -> str:
    state["rag_calls"] += 1

    result = await call_tool(
        tool_name="ragflow.search",
        payload={
            "query": query,
            "top_k": 5
        },
        state=state
    )

    return result["content"]
```

### 3、Tool Policy（真实治理，不是示例）

到这里，你已经正式补齐那 30% —— Tool 不再是“随便调”

```python
# policies/tool_policy.py
TOOL_POLICIES = {
    "ragflow.search": {
        "max_calls": 2,
        "roles": ["user", "admin"]
    }
}

def check_tool_policy(tool_name: str, state: dict):
    policy = TOOL_POLICIES.get(tool_name)
    if not policy:
        raise RuntimeError(f"No policy for tool {tool_name}")

    if state["role"] not in policy["roles"]:
        raise PermissionError("Role not allowed")

    if state["rag_calls"] >= policy["max_calls"]:
        raise RuntimeError("RAG call limit exceeded")
```

### 4、Model Plane：vLLM Client（无业务）

- vLLM：

  1. 不知道 Agent
  2. 不知道 Tool
  3. 只负责推理

```python
# models/llm.py
from openai import OpenAI

client = OpenAI(
    base_url="http://127.0.0.1:8001/v1",
    api_key="EMPTY"
)

def generate(prompt: str) -> str:
    resp = client.chat.completions.create(
        model="qwen2.5-7b",
        messages=[
            {"role": "system", "content": "You are a helpful assistant"},
            {"role": "user", "content": prompt}
        ]
    )
    return resp.choices[0].message.content
```

### 5、Agent Graph（只改一个节点）

- 这里你已经具备：

  1. LangGraph 控制流
  2. Tool Governance
  3. vLLM 推理
  4. RAGFlow 工具化

```python
# agents/graph.py（升级版）
from langgraph.graph import StateGraph, END
from agents.state import AgentState
from tools.ragflow_tool import rag_search
from models.llm import generate

async def decide(state: AgentState):
    state["need_rag"] = "是什么" in state["query"]
    return state

async def call_rag(state: AgentState):
    docs = await rag_search(state["query"], state)
    state["context"] = docs
    return state

async def final_answer(state: AgentState):
    prompt = state["query"]
    if state.get("context"):
        prompt += f"\n\n参考资料：{state['context']}"

    state["answer"] = generate(prompt)
    return state

def route(state: AgentState):
    if state["need_rag"]:
        return "rag"
    return "final"

builder = StateGraph(AgentState)
builder.add_node("decide", decide)
builder.add_node("rag", call_rag)
builder.add_node("final", final_answer)

builder.add_conditional_edges(
    "decide",
    route,
    {"rag": "rag", "final": "final"}
)

builder.add_edge("rag", "final")
builder.add_edge("final", END)

agent_graph = builder.compile()
```

七、外部服务启动方式（真实）

## 三、外部服务启动方式（真实）

1. 1️⃣ vLLM

   ```bash
      vllm serve Qwen/Qwen2.5-7B \
     --port 8001 \
     --dtype auto
   ```

2. 2️⃣ fastMCP（示例）

   ```bash
      fastmcp serve \
        --port 9000 \
        --tools ragflow.search
   ```

3. 3️⃣ Agent Gateway

   ```bash
      uvicorn app.main:app --reload
   ```

## 四、现在你已经到哪一步了？

你现在的系统已经是：

- ✅ Agent-First
- ✅ Tool Governance（fastMCP）
- ✅ RAGFlow 被降级
- ✅ vLLM 独立
- ✅ LangGraph 决策
- ❌ 还差：Audit / Replay / Memory（最后 10%）
