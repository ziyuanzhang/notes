# AI-9-最小可运行结构 2-对--生产级

- 这一步是真正把系统从“能跑”推到“生产级”的关键分水岭。
- 最小但真实可用的 Audit + Replay 实现，不引入复杂依赖、不改已有结构。

* 目标只有 3 个：

  1. 每一次 Agent 执行都有完整轨迹
  2. 可以把某一次执行完整 replay
  3. 不侵入 Agent 业务逻辑

## 一、 Audit + Replay 的最小新增结构

在当前结构上，只新增 4 个文件：

```bash
agent-gateway/
├─ storage/
│  ├─ audit_writer.py     # 写执行轨迹
│  ├─ audit_reader.py     # 读执行轨迹
│  ├─ replay_runner.py    # 回放 Agent
│  └─ models.py           # 统一数据结构
```

## 二、代码

### 1、统一执行轨迹模型（非常关键）

- 原则

  1. 不存 Prompt 也能 replay
  2. replay 的本质是：重放决策和工具路径

```python
# storage/models.py
from typing import TypedDict, List, Any
from datetime import datetime

class AuditEvent(TypedDict):
    ts: str
    node: str
    input: Any
    output: Any

class AgentRun(TypedDict):
    run_id: str
    query: str
    role: str
    events: List[AuditEvent]
```

### 2、Audit Writer（写执行轨迹）

```python
# storage/audit_writer.py
import json
import uuid
from datetime import datetime
from storage.models import AgentRun, AuditEvent

AUDIT_FILE = "agent_audit.jsonl"

def new_run(query: str, role: str) -> AgentRun:
    return {
        "run_id": str(uuid.uuid4()),
        "query": query,
        "role": role,
        "events": []
    }

def record_event(
    run: AgentRun,
    node: str,
    input_data,
    output_data
):
    run["events"].append({
        "ts": datetime.utcnow().isoformat(),
        "node": node,
        "input": input_data,
        "output": output_data
    })

def persist(run: AgentRun):
    with open(AUDIT_FILE, "a") as f:
        f.write(json.dumps(run, ensure_ascii=False) + "\n")

```

### 3、把 Audit 注入 Agent Graph（只加一层 wrapper）

```python
# 改造 agents/graph.py（关键）
from storage.audit_writer import record_event

def audited(node_name, fn):
    async def wrapper(state):
        before = dict(state)
        result = await fn(state)
        record_event(
            state["_run"],
            node=node_name,
            input_data=before,
            output_data=result
        )
        return result
    return wrapper
```

把你的节点包一层即可：

```python
  builder.add_node("decide", audited("decide", decide))
  builder.add_node("rag", audited("rag", call_rag))
  builder.add_node("final", audited("final", final_answer))
```

### 4、在 API 入口创建 run（1 行改动）

```python
# 改造 app/api_agent.py
from storage.audit_writer import new_run, persist

@router.post("/ask")
async def ask(req: AskReq):
    run = new_run(req.query, req.role)

    state = {
        "query": req.query,
        "role": req.role,
        "rag_calls": 0,
        "_run": run
    }

    result = await agent_graph.ainvoke(state)

    persist(run)
    return {
        "run_id": run["run_id"],
        "answer": result["answer"]
    }
```

到这里为止：

- ✅ 每次请求都会生成一条可审计记录
- ✅ 每个节点的输入 / 输出都被记录

### 5、Audit Reader（读取历史执行）

```python
# storage/audit_reader.py
import json

AUDIT_FILE = "agent_audit.jsonl"

def load_all():
    with open(AUDIT_FILE) as f:
        for line in f:
            yield json.loads(line)

def load_by_run_id(run_id: str):
    for run in load_all():
        if run["run_id"] == run_id:
            return run
    return None
```

### 6、Replay Runner（真正的回放）

```python
# storage/replay_runner.py
from storage.audit_reader import load_by_run_id

def replay(run_id: str):
    run = load_by_run_id(run_id)
    if not run:
        raise RuntimeError("Run not found")

    print(f"Replay run_id={run_id}")
    print(f"Query: {run['query']}")
    print("-" * 40)

    for event in run["events"]:
        print(f"[{event['ts']}] NODE={event['node']}")
        print("INPUT:", event["input"])
        print("OUTPUT:", event["output"])
        print("-" * 40)
```

运行：

```bash
python -m storage.replay_runner <run_id>
```

## 三、你现在已经具备什么（非常重要）

到这一步，你的系统已经：

- ✅ Agent 决策可解释
- ✅ Tool 调用可追踪
- ✅ 推理路径可回放
- ✅ 能回答「Agent 为什么这么做」
- ✅ 满足企业合规 / Debug / 复盘要求

这一步是 90% 的团队永远做不到的。

## 四、最后 10%（不是现在必须，但我给你方向）

如果你以后要继续：

1. Replay → Deterministic Replay（mock Tool / LLM）
2. Audit → OpenTelemetry / Trace
3. Memory → 从 Audit 中提炼长期记忆
4. Policy → 基于 Audit 做自动调优
