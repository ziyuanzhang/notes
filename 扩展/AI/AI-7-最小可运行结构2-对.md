# AI-7-最小可运行结构 2-对

- uvicorn app.main:app 能启动
- POST /agent/ask 能返回结果
- Agent → Tool → 返回，全链路闭合

## 一、目录结构（只保留关键文件）

```bash
agent-gateway/
├─ pyproject.toml
├─ app/
│  ├─ main.py
│  └─ api_agent.py
├─ agents/
│  ├─ graph.py
│  └─ state.py
├─ tools/
│  └─ rag_tool.py
└─ policies/
   └─ tool_policy.py

```

## 代码

### 关键文件 1：FastAPI 入口（唯一入口）

```python
# app/main.py
from fastapi import FastAPI
from app.api_agent import router

app = FastAPI(title="Agent Gateway (MVP)")

app.include_router(router, prefix="/agent")

```

### 关键文件 2：Agent API（不含推理）

❗ 这里 没有任何推理逻辑

```python
# app/api_agent.py
from fastapi import APIRouter
from pydantic import BaseModel
from agents.graph import agent_graph

router = APIRouter()

class AskReq(BaseModel):
    query: str
    role: str = "user"

@router.post("/ask")
async def ask(req: AskReq):
    state = {
        "query": req.query,
        "role": req.role,
        "rag_calls": 0
    }
    result = agent_graph.invoke(state)
    return {"answer": result["answer"]}

```

### 关键文件 3：Agent State（状态即控制面）

```python
# agents/state.py
from typing import TypedDict

class AgentState(TypedDict):
    query: str
    role: str
    rag_calls: int
    need_rag: bool
    answer: str
```

### 关键文件 4：Agent Graph（LangGraph 决策核心）

✅ 这是 真正的 Agent Control Plane

```python
# agents/graph.py
from langgraph.graph import StateGraph, END
from agents.state import AgentState
from tools.rag_tool import rag_search
from policies.tool_policy import allow_rag

def decide(state: AgentState):
    # 极简决策：问题里包含“是什么”就查知识
    state["need_rag"] = "什么" in state["query"]
    return state

def call_rag(state: AgentState):
    state["rag_calls"] += 1
    docs = rag_search(state["query"])
    state["answer"] = f"【来自RAG】{docs}"
    return state

def final_answer(state: AgentState):
    if not state.get("answer"):
        state["answer"] = f"【直接回答】{state['query']}"
    return state

def route(state: AgentState):
    if state["need_rag"] and allow_rag(state):
        return "rag"
    return "final"

builder = StateGraph(AgentState)
builder.add_node("decide", decide)
builder.add_node("rag", call_rag)
builder.add_node("final", final_answer)

builder.add_conditional_edges(
    "decide",
    route,
    {
        "rag": "rag",
        "final": "final"
    }
)

builder.add_edge("rag", "final")
builder.add_edge("final", END)

agent_graph = builder.compile()
```

### 关键文件 5：Tool（RAG 被彻底降级为工具）

- ❗Tool：

  - 无状态
  - 不知道 Agent
  - 不知道上下文

```python
# tools/rag_tool.py
def rag_search(query: str) -> str:
    # 模拟 RAGFlow
    return f"知识库中关于「{query}」的内容"
```

### 关键文件 6：Tool Policy（补齐那 30%）

```python
# policies/tool_policy.py
def allow_rag(state) -> bool:
    # 最简单的策略：每次最多 1 次
    return state["rag_calls"] < 1
```

⚠️ 注意：Policy 是代码，不是 prompt

## 三、如何运行（真实可跑）

1. 1️⃣ 安装依赖

   ```bash
       uv add fastapi uvicorn langgraph
   ```

2. 2️⃣ 启动服务

   ```bash
      uvicorn app.main:app --reload
   ```

3. 3️⃣ 测试请求

   ```bash
      curl -X POST http://127.0.0.1:8000/agent/ask \
        -H "Content-Type: application/json" \
        -d '{"query": "LangGraph 是什么"}'
   ```

   返回示例：

   ```json
   {
     "answer": "【来自RAG】知识库中关于「LangGraph 是什么」的内容"
   }
   ```

## 四、为什么这个最小示例是“正确的”

- ✔ 只有 /agent/ask 一个入口
- ✔ Agent 决定是否用 RAG
- ✔ RAG 是 Tool，不是入口
- ✔ Policy 控制 Tool 次数
- ✔ LangGraph 是控制面
- ✔ 后续可无痛接入 fastMCP / RAGFlow / vLLM

## 五、如何扩展

1. 1️⃣ 把 rag_tool.py 换成 fastMCP Client
2. 2️⃣ 把 tool_policy.py 拆成 ACL / Budget / Timeout
3. 3️⃣ 给 graph 加 Observe / Reflect
4. 4️⃣ 加 audit / replay
