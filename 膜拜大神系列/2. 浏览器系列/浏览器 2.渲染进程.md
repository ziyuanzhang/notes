## 渲染进程是如何工作的 [1.原文链接](https://zhuanlan.zhihu.com/p/47407398) [2.参考链接](https://www.cnblogs.com/fogwind/p/6160456.html)

渲染进程几乎负责 Tab 内的所有事情，渲染进程的核心目的在于转换 HTML CSS JS 为用户可交互的 web 页面。

渲染进程中主要包含以下线程：

- 主线程 Main thread
- 工作线程 Worker thread
- 排版线程 Compositor thread
- 光栅线程 Raster thread

#### 当渲染进程接收到导航的确认信息，开始接受 HTML 数据时；

1. 主线程会解析 HTML 文档，构建 DOM 树：  
   在解析 HTML 文档的同时， preload scanner 会同时运行“扫描文档”（不占据主线程）；
   当遇到 `<img>` `<link>` 等标签，preload scanner 会把这些请求传递给 Browser process 中的 network thread 进行相关资源的下载。  
   当遇到 `<script>` 标签时，渲染进程会停止解析 HTML，而去加载，解析和执行 JS 代码，（`async` 或 `defer` 另算）；  
    defer(延迟脚本):立即下载，文档解析完成再执行（DOMContentLoaded 事件触发之前执行）  
    async(异步脚本):立即下载，下载完在“浏览器空闲时”再执行(互不依赖；在 load 前，在 DOMContentLoaded 前后执行都可以)

2. 构建 CSS 规则树:（把 CSS 放 head 防止 css 阻塞渲染，CSS 解析可以与 DOM 解析同时进行）;

3. 构建渲染树：将 DOM 节点与 CSS 关联起来（header/display: none 不在渲染树中;visibility: hidden 在，伪元素也在）;  
   **注：** js 文件的下载不会阻塞其他线程（HTML 的解析，树的构建等）；js 的执行不会阻塞 CSS 的解析，但是会阻塞 HTML 文档的解析。  
    渲染树的构建又依赖 DOM 树和 CSS 规则树。所以 js 的执行会阻塞渲染树的构建。

4. 渲染树--布局：计算元素的位置和大小（输出盒子模型；float，absoulte，fixed 发生位置偏移；脱离文档流就是脱离渲染树）

5. 渲染树--绘制各元素：主线程会遍历布局树以创建绘制记录。绘制记录可以看做是记录各元素绘制先后顺序的笔记。
   <!-- 调用渲染器的 paint()方法在屏幕上显示其内容（由浏览器的 UI 后端组件完成） -->

6. 合成帧：主线程会遍历布局树来创建层树，一旦层树被创建，渲染顺序被确定，主线程会把这些信息通知给合成器线程（compositor 线程）；(添加了 `will-change` CSS 属性的元素，会被看做单独的一层)

   合成器线程会栅格化每一层。有的层的可以达到整个页面的大小，因此，合成器线程将它们分成多个磁贴，并将每个磁贴发送到栅格线程，栅格线程会栅格化每一个磁贴并存储在 GPU 显存中。  
   一旦磁贴被光栅化，合成器线程会收集称为绘制四边形的磁贴信息以创建合成帧。

   合成帧随后会通过 IPC 消息传递给浏览器进程，由于浏览器的 UI 改变或者其它拓展的渲染进程也可以添加合成帧，这些合成帧会被传递给 GPU 用以展示在屏幕上，如果滚动发生，合成器线程会创建另一个合成帧发送给 GPU。

   **优点：** 其工作无关主线程，合成器线程不需要等待样式计算或者 JS 执行，这就是为什么合成器相关的动画 最流畅，如果某个动画涉及到布局或者绘制的调整，就会涉及到主线程的重新计算，自然会慢很多。

**注：**

- 生成各种树，包括 dom tree, css tree, layout tree, layer true, render tree，这些是 Render Process 中的 GUI 渲染线程做的事。
- js 脚本的解析执行是同进程下的 js 引擎线程来做的，也就是大名鼎鼎的 V8 引擎。
- 至于定时器回调，是定时器线程来计数，计数完毕会把回调推入“事件触发线程”维护的任务队列，当 js 线程空闲并且此线程维护的微任务队列无事件，才会去任务队列拿宏任务执行处理。
