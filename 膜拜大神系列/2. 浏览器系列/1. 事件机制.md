JS 引擎并不是独立运行的，它运行在宿主环境中（浏览器、nodejs）;

**事件循环：** 所有的宿主环境都提供了一种机制来处理程序中多个块的执行，且执行每块时调用 JS 引擎，这种机制被称为事件循环;

例子：js 程序发出一个从服务器端获取数据的 ajax 请求，那你就在回调函数中设置好响应代码，然后 JS 引擎会通知宿主环境：我现在要暂停执行了，你一旦完成请求，拿到数据就调用这个函数；然后浏览器就会设置监听来自网络的请求，拿到数据，就会把回调函数出入事件循环中；

"事件"（js 代码执行）调度由宿主环境进行

- setTimeout()并没有把“回调函数”挂在到事件队列中；当定时器到时间后，宿主环境会把“回调函数”放到时间循环中；在未来的某个时刻的 tick 会摘下并执行；假如事件循环中有 20 个项目，回调函数需要排在其他项目之后，没有插队的能性；
- setTimeout()定时器不精确，只能保证在时间间隔前不会执行，可能会立刻执行也可能会之后执行，具体看事件队列状态；

* 程序通常被分成多个小块 在事件队列中一个接一个执行，和程序不相关的其他事件也可能会被加入队列中；

- ES6 的 Promise 的加入改变了（事件循环在哪管理）；将其纳入 JS 引擎势力范围，而不是只有宿主环境管理；因为 promise 能对事件循环队列的调度运行直接进行精确控制。

**注:**事件循环的每一轮成为一个 tick;

事件循环队列：类似于游乐园游戏，玩过一个后，需要重新到队尾排队；
任务队列：（Promise 为代表）类似于玩过游戏后可以查对；一个任务可能引起更多任务被添加到同一个队列末尾，形成无线循环。
