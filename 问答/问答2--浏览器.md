#

## 默认浏览器、手机 webview 内核、各家小程序的运行环境

H5 页面：运行环境 1、浏览器；2、APP 的 web-view 组件；3、小程序提供的 web-view 组件；
微信小程序：运行环境是非完整的浏览器，是基于浏览器内核完全重构的一个内置解析器，针对小程序专门做了优化（功能和流畅性更好）

## 垃圾回收：参考“浏览器系列 / 垃圾回收机制”

栈中数据回收：执行状态指针 ESP 在执行栈中移动，移过某执行上下文，就会被销毁；
堆中数据回收：V8 引擎采用标记-清除算法；

- 注：在垃圾回收阶段，应用程序的执行会暂停，等待回收执行完毕后，再恢复程序的执行。

## 编译器和解析器：V8 如何执行一段 JavaScript 代码的

计算机语言可以分为两种：编译型和解释型语言。
编译型语言：经过编译器编译后保留机器能读懂的二进制文件，比如 C/C++，go 语言。
解释型语言: 是在程序运行时通过解释器对程序进行动态解释和执行，比如 Python，JavaScript 语言。

- 编译型语言的编译过程：编译器首先将代码进行词法分析、语法分析，生成抽象语法树（AST），然后优化代码，最后生成处理器能够理解的机器码；
- 解释型语言解释过程：解释器会对代码进行词法分析、语法分析，并生产抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后根据字节码执行程 序；
- AST 的生成：第一阶段是分词（词法分析），将一行行源码拆解成一个个 token（语法上不可再分、最小单个字符）。第二阶段是解析（语法分析），将上一步 生成的 token 数据，根据语法规则转为 AST，这一阶段会检查语法错误；
- 字节码存在的意义：直接将 AST 转化为机器码，执行效率是非常高，但是消耗大量内存，从而先转化为字节码解决内存问题；
- 解释器 ignition 在解释执行字节码，同时会手机代码信息，发现某一部分代码是热点代码（HotSpot），编译器把热点的字节码转化为机器码，并保存起来， 下次使用；
- 字节码配合解释器和编译器的计数实现称为即时编译（JIT）。

## 页面性能：如何系统优化页面

一个页面有三个阶段：加载阶段、交互阶段和关闭阶段。

1. 加载阶段：

   - 减少关键资源个数;
   - 降低关键资源大小;
   - 降低关键资源的 RTT（Round Trip Time） 次数;
     RTT 就是这里的往返时延。它是网络中一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认，总共经历的时延。

2. 交互阶段：尽量减少一帧的生成时间。

   - 减少 js 脚本执行时间。
   - 避免强制同步布局：js 强制将“计算样式”和“布局操作”提前到当前的任务中。
   - 避免布局抖动： 在一段 js 代码中，反复执行布局操作。
   - 合理利用 CSS 合成动画：标记 will-change。
     合成动画是在“合成线程”上执行的；如果主线程被 js 或者一些布局任务占用，CSS 动画依然能继续执行（它不会触发重排或者重绘）。
   - 避免频繁的垃圾回收。

## TCP/IP 协议 ：参考“网络系列”

1. 应用层-->http/FTP/SMTP;应用间通信；数据;
2. 传输层 ---->TCP/UDP 协议（主机到主机）；提供端口号：80；
3. 网络层 ---->IP 协议（IP 地址-->IP 地址）；
4. 链路层 ---->多种底层网络协议 Ethernet,wifi(设备-->设备)
5. 物理层 ---->传输介质：双绞线、同轴电缆、光纤

## HTTP1 / HTTP2 / HTTP3

1. HTTP/0.9: 基于 TCP 协议，三次握手建立连接，发送一个 GET 请求行（没有请求头和请求体），服务器接收请求之后，读取对应 HTML 文件，数据以 ASCII 字符流返回，传输完成断开连接；

2. HTTP/1.0: 增加请求头和响应头来进行协商，在发起请求时通过请求头告诉服务器它期待返回什么类型问题、什么形式压缩、什么语言以及文件编码。引入来状态吗，Cache 机制等；

3. HTTP/1.1:

   - 改进持久化连接，解决建立 TCP 连接、传输数据和断开连接带来的大量开销，支持在一个 TCP 连接上可以传输多个 HTTP 请求，目前浏览器对于一个域名同时允许建立 6 个 TCP 持久连接；
   - 引入 Chunk transfer 支持动态生成内容：服务器将数据分割成若干任意大小的数据块，每个数据块发送时附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。在 HTTP/1.1 需要在响应头中设置完整的数据大小，如 Content-Length。
   - **问题**：TCP 慢启动；同时开启多条 TCP 连接，会竞争固定宽带；对头阻塞问题；

4. HTTP/2 :

   - 同一个域名下只使用一个 TCP 长连接和消除对头阻塞问题；
   - 头部压缩：对请求头和响应头进行压缩；
   - 设置请求优先级：发送请求可以设置请求优先级，服务器可以优先处理；
   - 服务器推送：请求一个 HTML 页面，服务器可以知道引用了哪些 JavaScript 和 CSS 文件，附带一起发送给浏览器；
   - 多路复用的实现：HTTP/2 添加了二进制分帧层，将发送或响应数据经过二进制分帧处理，转化为一个个带有请求 ID 编号的帧，服务器或者浏览器接收到响应帧后，根据相同 ID 帧合并为一条完整信息；

   - **TCP 问题**：如果在传输过程中，有一个数据因为网络故障或者其他原因丢失，那么整个连接会处于暂停状态，只有等到该数据重新传输；

5. HTTP/3
   - HTTP/3 选择了一个折衷的方法，基于现有的 UDP 协议，实现类似 TCP 多路复用，传输可靠等功能，称为 QULC 协议；
   - QULC 实现类似 TCP 流量控制，传输可靠功能；集成 TLS 加密功能；实现多路复用功能；

## HTTPS

1. 在 TCP 和 HTTP 之间插入一个安全层，所有经过安全层的数据都会被加密或者解密；
2. 作用：1、保证数据传输的安全；2、确认网站的真实性。
3. 对称加密：
   浏览器发送加密套件列表和一个随机数 client-random，服务器会从加密套件中选取一个加密套件，然后生成一个随机数 service-random，返回给浏览器。这样浏览器和服务器都有相同 client-random 和 service-random，再用相同的方法将两者混合生成一个密钥 master secret，双方就可以进行数据加密传输了；
   - 缺点：client-random 和 service-random 的过程都是明文，黑客可以拿到协商的加密套件和双方随机数，生成密钥，数据可以被破解；
4. 非对称加密：
   浏览器发送加密套件列表给服务器，服务器选择一个加密套件，返回加密套件和公钥，浏览器用公钥加密数据，服务器用私钥解密；
   - 缺点：加密效率太低；初次通信黑客可以获取公钥。
5. 对称加密结合非对称加密：初次非对称，以后对称；

**注：**2 种加密方式 理论上都可以暴力破解；对称加密破解的概率大点；

## 301、302、303、304、307

1. 301：重定向--请求的资源已永久移动到新位置
2. 302：重定向--请求的资源临时从不同的 URI 响应请求
3. 303：对 POST 请求，请求已被处理，客户端自动使用 GET 方式请求
4. 304：缓存
5. 307：对 POST 请求，请求未被处理，客户端重新使用 POST 方式请求

## RESTful 接口

1. url 都是名词，不能出现动词，例如：http://a.com/bbb/friends可以，http://a.com/bbb/deleteFriends 不可以
2. 增（POST），删（DELETE），改（PUT），查（GET）
3. 好处：一套统一的接口，在 web，ios，android 三端都可以用相同的接口

## WebSocket 事件

- 事件:

  1. open：Socket.onopen-->连接建立时触发;
  2. message：Socket.onmessage -->客户端接收服务端数据时触发 ;
  3. error：Socket.onerror-->通信发生错误时触发;
  4. close：closeSocket.onclose-->连接关闭时触发;

- 方法：

  1. Socket.send()-->使用连接发送数据
  2. Socket.close()-->关闭连接

## http 协议 与 webSocket 协议

1. http 协议: http 协议建立链接也必须要有三次握手才能发送信息。（客户端是主动的，服务器是被动的）
2. webSocket 协议:只需建立一次 Request/Response 消息对，之后都是 TCP 连接 （客服端和浏览器可以同时发送信息）;
   - 好处：降低服务器的压力;减少部分多余的信息(不必带 head 的部分信息)。

## 前端缓存

- Service Worker；
- Memory Cache（内存缓存）；
- Disk Cache（硬盘缓存）；
- Push Cache（推送缓存 - http2.0）；

1. Service Worker：运行在浏览器背后的独立线程；

   - 传输协议必须为  HTTPS（因为  Service Worker  中涉及到请求拦截）；
   - 可以自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。
   - 缓存分三步：

     1. 先注册  Service Worker；
     2. 监听 install 事件，缓存文件；
     3. 下次访问，拦截请求；
     4. 存在缓存直接读取缓存文件，否则就去请求数据；

   - 浏览器第一次请求拿到结果，会根据【响应头的缓存标识】决定是否缓存；
     是：则将【请求结果和缓存标识】存入缓存中；
     只能缓存 GET 请求；

2. memory cache（内存缓存）：读取快，存储时间短（关闭  Tab  页，内存中的缓存就被释放）;

   应用：preloader（`<link rel="prefetch">`）显式指定的预加载资源，也会被放入 memory cache 中

3. memory cache（硬盘缓存）：读取慢，存储时间长，容量大

   放硬盘：1.大文件 2.内存占用率高；

   图片，字体，js，css 看大小：小放内存，大放硬盘；

   - 浏览器缓存：通过 HTTP Header  实现：Expires  和  Cache-Control；

     - Expires ：http 1.0 受本地时间限制（绝对时间）；
     - Cache-Control：

       - public：允许所有方缓存 (包括客户端和代理服务器， 如 CDN)；
       - private：只有客户端才可以缓存，代理服务器不能缓存；
       - no-cache：每次必须先询问服务器资源是否已经更新，未更新 304；
       - no-store：不使用缓存；

       - max-age：即最大有效时间（秒-相对时间）
       - must-revalidate：缓存在考虑使用【旧资源】，必须发请求验证；

   - 强制缓存：直接用（不发请求验证）状态码：200；例如：
     1、Cache-Control:max-age=600；
     2、Expires:<最后期限>

   - 对比缓存（协商缓存）：每次需要向服务器请求对比，缓存生效不传回 body;
     - Etag / If-None-Match：优先级--高
       - Etag：第一次请求，返回的资源**唯一标示符**；
       - If-None-Match：第二次请求发给服务端，服务端对比，
         1、相同则用缓存，状态码：304；
         2、不同返回新的资源，状态码：200
     - Last-Modified / If-Modified-Since ：
       - Last-Modified：第一次请求，返回的资源**最后修改时间**；
       - If-Modified-Since：第二次请求发给服务端，服务端对比 资源的最后修改时间
         1、服务端时间 <= 请求中的资源时间，则用缓存，状态码：304；
         2、服务端时间 > 请求中的资源时间，则返回新的，状态码：200

4. Push Cache（推送缓存 - http2.0）：以上三种缓存都没有命中时才会被使用，一旦会话结束就被释放

## Cookie 、 localStorage 、 sessionStorage

- 存储大小： Cookie：4K； localStorage / sessionStorage：5M；

- 存储位置：Cookie：每次 http 请求都会带 ；localStorage / sessionStorage：都保存在客户端，不与服务器进行通信；

- 生命周期：

  - localStorage: 除非被清除，否则永久保存
  - sessionStorage:仅在当前会话下有效，关闭页面或浏览器后被清除
  - cookie:

    1. HttpOnly:可以防止客户端脚本修改
    2. Expires :设置过期时间
    3. Max-Age :设置多少秒数后失效
    4. Domain :指定送达的主机名
    5. Path 指定送达的 URL 路径
    6. Secure:只能用于 HTTPS 协议
    7. SameSite：Strict 仅允许一方；
       Lax 允许部分第三方请求；
       None 无论是否跨站；

**注：**
1、通过点击链接（或者  window.open）打开的新标签页属于同一个 session 的；
2、新开一个标签页总是会初始化一个新的 session，即使网站是一样的，它们也不属于同一个 session；

## 同源策略：协议、域名和端口号相同的 URL 是同源的

## XSS 攻击(跨站脚本攻击)：为什么 cookie 中有 httpOnly 属性

XSS  攻击是指浏览器中执行恶意脚本, 然后拿到用户的信息进行操作。

- 主要分为存储型、反射型和文档型。

  1. 存储型：(持久型)提交了数据，并且存入了数据库，别人访问这个页面的时候就会自动出发;
  2. 反射型：(非持久型)提交了数据，但是这是对你这次访问产生了影响，并非持久性攻击;
  3. DOM 的：通过 JS 代码对网页进行修改，变化和执行。当 JS 代码执行后的结果产生了 XSS 漏洞的话，这就是 DOM 型 XSS，再根据该 XSS 能否被存储进数据库中，可再细分为反射型和存储型;

- 防范的措施包括:

  1. 一个信念: 不要相信用户的输入，对输入内容转码或者过滤，让其不可执行。
  2. 两个利用: 利用 CSP（只允许页面向允许的域名发起跨域请求）；利用 Cookie 的 HttpOnly 属性。

## CSRF 攻击（跨站请求伪造）：陌生连接不要随便点

- CSRF 攻击攻击原理及过程如下：

  1. 用户打开浏览器，访问受信任网站 A，输入用户名和密码请求登录网站 A；
  2. 用户信息通过验证后，网站 A 产生 Cookie 信息并返回给浏览器，此时用户登录网站 A 成功，可以正常发送请求到网站 A；
  3. 用户未退出网站 A 之前，在同一浏览器中，打开一个 TAB 页访问网站 B；
  4. 网站 B 接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点 A；
  5. 浏览器在接收到这些攻击性代码后，根据网站 B 的请求，在用户不知情的情况下携带 Cookie 信息，向网站 A 发出请求。网站 A 并不知道该请求其实是由 B 发起的，所以会根据用户的 Cookie 信息以用户的权限处理该请求，导致来自网站 B 的恶意代码被执行。

- demo:

  1. git 请求：

     ```code
     <img src="http://www.study.com/admin/resetPassword?id=1" />
     ```

  2. post 请求：

     ```code
        <body>
           <form action="https://vulnerable-website.com/email/change" method="POST">
              <input type="hidden" name="email" value="pwned@evil-user.net" />
              </form>
           <script>
              document.forms[0].submit();
           </script>
        </body>
     ```

- 防范措施：

  1. 随机化 Token（CSRF Token）：Token 是用于验证网站请求者身份的一种机制，可以防止 CSRF 攻击。该 Token 会在每次访问页面时刷新，以确保每次请求都需要新的 Token。
  2. Cookie SameSite 属性：应用于 Cookie，防止跨站请求伪造攻击，避免恶意网站使用认证（sso）cookie 访问目标网站或者欺骗 cookie 窃取用户数据。
  3. 限制 cookies 操作：不能在 cookie 中加入用户敏感信息，避免 cookie 的信息外泄。
  4. 验证请求的来源站点，请求头中的 Referer 和 Origin 属性

**XSS 与 CSRF 的区别**：XSS 是直接盗取到了用户的权限，然后实施破坏，而 CSRF 是借用户的权限完成攻击，攻击者并没有拿到用户的权限。

## PWA：解决 web 应用哪些问题

- PWA（Progressive Web App），渐进式 Web 应用。一个渐进式过渡方案，让普通站点过渡到 Web 应用，降低站点改造代价，逐渐支持新技术，而不是一步到位；
- PWA 引入 ServiceWorker 来试着解决离线存储和消息推送问题，引入 mainfest.json 来解决一级入口问题；
- 暗转了 ServiceWorker 模块之后，WebApp 请求资源时，会先通过 ServiceWorker，让它判断是返回 Serviceworker 缓存的资源还是重新去网络请求资源，一切的控制权交给 ServiceWorker 来处理；
- 在目前的 Chrome 架构中，Service Worker 是运行在浏览器进程中的，因为浏览器进程生命周期是最长的，所以在浏览器的生命周期内，能够为所有的页面提供服务；

## WebComponent：像搭积木一样构建 web 应用

- CSS 的全局属性会阻碍组件化，DOM 也是阻碍组件化的一个因素，因为页面中只有一个 DOM，任何地方都可以直接读取和修改 DOM；
- WebComponent 提供了对局部试图封装能力，可以让 DOM、CSSOM 和 JavaScript 运行在局部环境中；
- template 创建模版，查找模版内容，创建影子 DOM，模版添加到影子 DOM 上；
- 影子 DOM 可以隔离全局 CSS 和 DOM，但是 JavaScript 是不会被隔离的；
