# 考试

1. 信号量(S)与 PV 操作：
   - 信号量(S):是一种特殊的变量，；表示资源数量；为负数时表示排队进程数。
   - P：要资源；V：释放资源；
2. 页，段储存；页/段混合储存； `2^13 = 2^3*2^10 = 8kb`

## （渐进）时间复杂度 --- 指运行的次数

### 查找算法

1. 顺序查找：从头到尾与表中元素比较；
2. 二分查找（折半查找）：（前提：原始数据是`有序数组`）

   - mid = (low+high)/2
   - 复杂度：O(log<sub>2</sub>n)

3. 哈希查找（散列函数）: 没空间，可以循环放前面；
   散列函数为 H(key) = key%11,对于关键码序列(23,40,91,17,19,10,,31,65,26),用线性探查法解决冲突构造的哈希表为：

   |          |     |     |     |     |     |     |     |     |     |     |     |
   | -------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
   | 哈希地址 | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  |
   | 关键码   | 65  | 23  |     | 91  | 26  |     | 17  | 40  | 19  | 31  | 10  |

### 排序算法

| 类别     | 排序方法   | 时间复杂度            | 时间复杂度                    | 空间复杂度 | 稳定性 |
| -------- | ---------- | --------------------- | ----------------------------- | ---------- | ------ |
|          |            | 平均情况              | 特殊情况                      | 辅助储存   |        |
| 插入排序 | 直接插入   | O(n<sup>2</sup>)      | 基本有序最优 O(n)             | O(1)       | 稳定   |
| 插入排序 | shell 排序 | O(n<sup>1.3</sup>)    | --                            | O(1)       | 不稳定 |
| 选择排序 | 直接选择   | O(n<sup>2</sup>)      | --                            | O(1)       | 不稳定 |
| 选择排序 | 堆选择     | O(n log<sub>2</sub>n) | --                            | O(1)       | 不稳定 |
| 交换排序 | 冒泡排序   | O(n<sup>2</sup>)      | --                            | O(1)       | 稳定   |
| 交换排序 | 快速排序   | O(n log<sub>2</sub>n) | 基本有序最差 O(n<sup>2</sup>) | O(1)       | 不稳定 |
|          | 归并排序   | O(n log<sub>2</sub>n) | --                            | O(n)       | 稳定   |
|          | 基数排序   | O(d(n+rd))            | --                            | O(rd)      | 稳定   |

- shell 排序：分组；奇数做增量，分组，组内插入排序；
  57、68、59、52、72、28、96、33、24、19

  1. d1 = n/2 = 5; （取奇数）【1、6】【2、7】【3、8】【4、9】【5、10】
  2. d2 = d1/2 = 3;（取奇数）【1、4、7、10】【2、5、8】【3、6、9】
  3. d3 = d2/2 = 1;（取奇数）【1、2、3、4、5、6、7、8、9、10】

- 直接选择：选择最小的和第一个交换位置，剩余中选择最小的和第二个交换位置，以此类推；
- 堆选择：小顶堆，大顶堆（最小二叉树、最大二叉树）
  `arr[0]`是堆顶；`n/2`是最后一个父节点；`2n+1`是左节点；`2n+2`是右节点

  1. 组成小顶堆（大顶堆），拿走顶部的；
  2. 剩余的再组成小顶堆（大顶堆），拿走顶部的；
  3. 以此类推

     ![堆排序](./img/堆排序.png)

- 冒泡排序：相邻元素之间比较并交换；

- 快速（交换）排序：

  1. 找到基准的元素，比它小的放左边数组，比它大的放右边数组；
  2. 对左右数组，各找出基准元素；比它小的放左边数组，比它大的放右边数组；
  3. 一次类推；

- 归并排序/合并排序：

  1. 两两分组，再排序；【1、2】【3、4】【5、6】【7、8】
  2. 相邻两组，依次比较、获取最小值、排序； 【1、2、3、4】【5、6、7、8】
  3. 以此类推；

  ![归并排序](./img/归并排序.png)

- 基数排序：
  1. 新建一个长度为 10 的二维数组【arr1】；原始数组按照`个位`放到【arr1】的对应小标中；
  2. 将 arr1 扁平化成一维数组【arrA1】；
  3. 新建一个长度为 10 的二维数组【arr2】；数组【arrA1】按照`十位`放到【arr2】的对应小标中；
  4. 将 arr2 扁平化成一维数组【arrA2】；
  5. 新建一个长度为 10 的二维数组【arr3】；数组【arrA2】按照`十位`放到【arr3】的对应小标中；
  6. 依次类推，直到数组中最大位数；
  7. 最后扁平化最后的二位数组；

### 排序选择：

1. 当数据 n 较小时，采用 直接插入排序/简单选择排序；
2. 当数据基本有序，采用直接插入排序/冒泡排序；
3. 当 n 很大且`关键字【位数较少】`时，采用基数排序；
